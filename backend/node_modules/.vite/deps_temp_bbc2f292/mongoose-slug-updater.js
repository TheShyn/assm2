import {
  require_lodash
} from "./chunk-4H6IFO4E.js";
import {
  __commonJS
} from "./chunk-CQXHTUV2.js";

// node_modules/deepdash/private/getMixOrPatchIn.js
var require_getMixOrPatchIn = __commonJS({
  "node_modules/deepdash/private/getMixOrPatchIn.js"(exports, module) {
    "use strict";
    function getMixOrPatchIn(_) {
      function mixOrPatchIn(name, method, chain) {
        if (!_[name]) {
          if (_.mixin) {
            var patch = {};
            patch[name] = method;
            _.mixin(patch, { chain });
          } else {
            _[name] = method;
          }
        }
        return _;
      }
      return mixOrPatchIn;
    }
    module.exports = getMixOrPatchIn;
  }
});

// node_modules/deepdash/getCondense.js
var require_getCondense = __commonJS({
  "node_modules/deepdash/getCondense.js"(exports, module) {
    "use strict";
    function getCondense(_) {
      function condense(arr) {
        var indexes = [];
        for (var i = 0; i < arr.length; i++) {
          if (!(i in arr)) {
            indexes.push(i);
          }
        }
        var length = indexes.length;
        while (length--) {
          arr.splice(indexes[length], 1);
        }
        return arr;
      }
      return condense;
    }
    module.exports = getCondense;
  }
});

// node_modules/deepdash/addCondense.js
var require_addCondense = __commonJS({
  "node_modules/deepdash/addCondense.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getCondense = require_getCondense();
    function addCondense(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("condense", getCondense(), !getCondense.notChainable);
    }
    module.exports = addCondense;
  }
});

// node_modules/deepdash/getPathToString.js
var require_getPathToString = __commonJS({
  "node_modules/deepdash/getPathToString.js"(exports, module) {
    "use strict";
    var rxArrIndex = /\D/;
    var rxVarName = /^[a-zA-Z_$]+([\w_$]*)$/;
    var rxQuot = /"/g;
    function joinPaths() {
      var paths = [], len = arguments.length;
      while (len--)
        paths[len] = arguments[len];
      return paths.reduce(
        function(acc, p) {
          return acc ? !p || p.startsWith("[") ? "" + acc + p : acc + "." + p : p;
        },
        ""
      );
    }
    function getPathToString(_) {
      function pathToString(path) {
        var prefixes = [], len = arguments.length - 1;
        while (len-- > 0)
          prefixes[len] = arguments[len + 1];
        prefixes = prefixes.filter(function(p) {
          return p !== void 0;
        });
        if (_.isString(path)) {
          return joinPaths.apply(void 0, prefixes.concat([path]));
        }
        if (!Array.isArray(path)) {
          return void 0;
        }
        prefixes = joinPaths.apply(void 0, prefixes);
        return path.reduce(function(acc, value) {
          var type = typeof value;
          if (type === "number") {
            if (value < 0 || value % 1 !== 0) {
              return acc + '["' + value + '"]';
            } else {
              return acc + "[" + value + "]";
            }
          } else if (type !== "string") {
            return acc + '["' + value + '"]';
          } else if (!value) {
            return acc + '[""]';
          }
          if (!rxArrIndex.test(value)) {
            return acc + "[" + value + "]";
          }
          if (rxVarName.test(value)) {
            if (acc) {
              return acc + "." + value;
            } else {
              return "" + acc + value;
            }
          }
          return acc + '["' + value.replace(rxQuot, '\\"') + '"]';
        }, prefixes);
      }
      return pathToString;
    }
    getPathToString.notChainable = true;
    module.exports = getPathToString;
  }
});

// node_modules/deepdash/private/isObject.js
var require_isObject = __commonJS({
  "node_modules/deepdash/private/isObject.js"(exports, module) {
    "use strict";
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/deepdash/private/getIterate.js
var require_getIterate = __commonJS({
  "node_modules/deepdash/private/getIterate.js"(exports, module) {
    "use strict";
    var getPathToString = require_getPathToString();
    var isObject = require_isObject();
    var rxVarName = /^[a-zA-Z_$]+([\w_$]*)$/;
    var rxQuot = /"/g;
    var has = Object.prototype.hasOwnProperty;
    function getIterate(_) {
      var pathToString = getPathToString(_);
      function iterate(item) {
        var options = item.options;
        var obj = item.obj;
        var callback = item.callback;
        options.pathFormatArray = options.pathFormat == "array";
        item.depth = 0;
        var broken = false;
        var breakIt = function() {
          broken = true;
          return false;
        };
        while (item) {
          if (broken) {
            break;
          }
          if (!item.inited) {
            item.inited = true;
            item.info = describeValue(item.value, options.ownPropertiesOnly);
            if (options.checkCircular) {
              item.circularParentIndex = -1;
              item.circularParent = null;
              item.isCircular = false;
              if (item.info.isObject && !item.info.isEmpty) {
                var parent = item.parent;
                while (parent) {
                  if (parent.value === item.value) {
                    item.isCircular = true;
                    item.circularParent = parent;
                    item.circularParentIndex = item.depth - parent.depth - 1;
                    break;
                  }
                  parent = parent.parent;
                }
              }
            }
            item.children = [];
            if (options.childrenPath) {
              options.childrenPath.forEach(function(cp, i) {
                var children = _.get(item.value, cp);
                var info = describeValue(children, options.ownPropertiesOnly);
                if (!info.isEmpty) {
                  item.children.push([
                    cp,
                    options.strChildrenPath[i],
                    children,
                    info
                  ]);
                }
              });
            }
            item.isLeaf = item.isCircular || options.childrenPath !== void 0 && !item.children.length || !item.info.isObject || item.info.isEmpty;
            item.needCallback = (item.depth || options.includeRoot) && (!options.leavesOnly || item.isLeaf);
            if (item.needCallback) {
              var contextReader = new ContextReader(obj, options, breakIt);
              contextReader.setItem(item, false);
              try {
                item.res = callback(
                  item.value,
                  item.key,
                  item.parent && item.parent.value,
                  contextReader
                );
              } catch (err) {
                if (err.message) {
                  err.message += "\ncallback failed before deep iterate at:\n" + pathToString(item.path);
                }
                throw err;
              }
            }
            if (broken) {
              break;
            }
            if (item.res !== false) {
              if (!broken && !item.isCircular && item.info.isObject) {
                if (options.childrenPath !== void 0 && (item.depth || !options.rootIsChildren)) {
                  item.childrenItems = [];
                  if (item.children.length) {
                    item.children.forEach(function(ref) {
                      var cp = ref[0];
                      var scp = ref[1];
                      var children = ref[2];
                      var info = ref[3];
                      item.childrenItems = item.childrenItems.concat(info.isArray ? getElements(item, children, options, cp, scp) : getOwnChildren(item, children, options, cp, scp));
                    });
                  }
                } else {
                  item.childrenItems = item.info.isArray ? getElements(item, item.value, options, [], "") : getOwnChildren(item, item.value, options, [], "");
                }
              }
            }
            item.currentChildIndex = -1;
          }
          if (item.childrenItems && item.currentChildIndex < item.childrenItems.length - 1) {
            item.currentChildIndex++;
            item.childrenItems[item.currentChildIndex].parentItem = item;
            item = item.childrenItems[item.currentChildIndex];
            continue;
          }
          if (item.needCallback && options.callbackAfterIterate) {
            var contextReader$1 = new ContextReader(obj, options, breakIt);
            contextReader$1.setItem(item, true);
            try {
              callback(
                item.value,
                item.key,
                item.parent && item.parent.value,
                contextReader$1
              );
            } catch (err) {
              if (err.message) {
                err.message += "\ncallback failed after deep iterate at:\n" + pathToString(item.path);
              }
              throw err;
            }
          }
          item = item.parentItem;
        }
      }
      return iterate;
      function getElements(item, children, options, childrenPath, strChildrenPath) {
        var strChildPathPrefix;
        if (!options.pathFormatArray) {
          strChildPathPrefix = item.strPath || "";
          if (strChildrenPath && strChildPathPrefix && !strChildrenPath.startsWith("[")) {
            strChildPathPrefix += ".";
          }
          strChildPathPrefix += strChildrenPath || "";
        }
        var res = [];
        for (var i = 0; i < children.length; i++) {
          var val = children[i];
          if (val === void 0 && !(i in children)) {
            continue;
          }
          var strChildPath = void 0;
          var pathFormatString = !options.pathFormatArray;
          if (pathFormatString) {
            strChildPath = strChildPathPrefix + "[" + i + "]";
          }
          res.push({
            value: val,
            key: i + "",
            path: (item.path || []).concat(childrenPath, [i + ""]),
            strPath: strChildPath,
            depth: item.depth + 1,
            parent: {
              value: item.value,
              key: item.key,
              path: pathFormatString ? item.strPath : item.path,
              parent: item.parent,
              depth: item.depth,
              info: item.info
            },
            childrenPath: childrenPath.length && childrenPath || void 0,
            strChildrenPath: strChildrenPath || void 0
          });
        }
        return res;
      }
      function getOwnChildren(item, children, options, childrenPath, strChildrenPath) {
        var strChildPathPrefix;
        if (!options.pathFormatArray) {
          strChildPathPrefix = item.strPath || "";
          if (strChildrenPath && strChildPathPrefix && !strChildrenPath.startsWith("[")) {
            strChildPathPrefix += ".";
          }
          strChildPathPrefix += strChildrenPath || "";
        }
        var res = [];
        var pathFormatString = !options.pathFormatArray;
        for (var childKey in children) {
          if (options.ownPropertiesOnly && !has.call(children, childKey)) {
            continue;
          }
          var strChildPath = void 0;
          if (pathFormatString) {
            if (rxVarName.test(childKey)) {
              if (strChildPathPrefix) {
                strChildPath = strChildPathPrefix + "." + childKey;
              } else {
                strChildPath = "" + childKey;
              }
            } else {
              strChildPath = strChildPathPrefix + '["' + childKey.replace(
                rxQuot,
                '\\"'
              ) + '"]';
            }
          }
          res.push({
            value: children[childKey],
            key: childKey,
            path: (item.path || []).concat(childrenPath, [childKey]),
            strPath: strChildPath,
            depth: item.depth + 1,
            parent: {
              value: item.value,
              key: item.key,
              path: pathFormatString ? item.strPath : item.path,
              parent: item.parent,
              depth: item.depth,
              info: item.info
            },
            childrenPath: childrenPath.length && childrenPath || void 0,
            strChildrenPath: strChildrenPath || void 0
          });
        }
        return res;
      }
    }
    var ContextReader = function ContextReader2(obj, options, breakIt) {
      this.obj = obj;
      this._options = options;
      this["break"] = breakIt;
    };
    var prototypeAccessors = { path: { configurable: true }, parent: { configurable: true }, parents: { configurable: true }, depth: { configurable: true }, isLeaf: { configurable: true }, isCircular: { configurable: true }, circularParentIndex: { configurable: true }, circularParent: { configurable: true }, childrenPath: { configurable: true }, info: { configurable: true } };
    ContextReader.prototype.setItem = function setItem(item, afterIterate) {
      this._item = item;
      this.afterIterate = afterIterate;
    };
    prototypeAccessors.path.get = function() {
      return this._options.pathFormatArray ? this._item.path : this._item.strPath;
    };
    prototypeAccessors.parent.get = function() {
      return this._item.parent;
    };
    prototypeAccessors.parents.get = function() {
      if (!this._item._parents) {
        this._item._parents = [];
        var curParent = this._item.parent;
        while (curParent) {
          this._item._parents[curParent.depth] = curParent;
          curParent = curParent.parent;
        }
      }
      return this._item._parents;
    };
    prototypeAccessors.depth.get = function() {
      return this._item.depth;
    };
    prototypeAccessors.isLeaf.get = function() {
      return this._item.isLeaf;
    };
    prototypeAccessors.isCircular.get = function() {
      return this._item.isCircular;
    };
    prototypeAccessors.circularParentIndex.get = function() {
      return this._item.circularParentIndex;
    };
    prototypeAccessors.circularParent.get = function() {
      return this._item.circularParent;
    };
    prototypeAccessors.childrenPath.get = function() {
      return this._options.childrenPath !== void 0 && (this._options.pathFormatArray ? this._item.childrenPath : this._item.strChildrenPath) || void 0;
    };
    prototypeAccessors.info.get = function() {
      return this._item.info;
    };
    Object.defineProperties(ContextReader.prototype, prototypeAccessors);
    function isObjectEmpty(value, ownPropertiesOnly) {
      for (var key in value) {
        if (!ownPropertiesOnly || has.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    function describeValue(value, ownPropertiesOnly) {
      var res = { isObject: isObject(value) };
      res.isArray = res.isObject && Array.isArray(value);
      res.isEmpty = res.isArray ? !value.length : res.isObject ? isObjectEmpty(value, ownPropertiesOnly) : true;
      return res;
    }
    module.exports = getIterate;
  }
});

// node_modules/deepdash/getEachDeep.js
var require_getEachDeep = __commonJS({
  "node_modules/deepdash/getEachDeep.js"(exports, module) {
    "use strict";
    var getIterate = require_getIterate();
    function getEachDeep(_) {
      var iterate = getIterate(_);
      function eachDeep(obj, callback, options) {
        if (callback === void 0) {
          callback = _.identity;
        }
        options = _.merge(
          {
            includeRoot: !Array.isArray(obj),
            pathFormat: "string",
            checkCircular: false,
            leavesOnly: false,
            ownPropertiesOnly: true
            //
          },
          options || {}
        );
        if (options.childrenPath !== void 0) {
          if (!options.includeRoot && options.rootIsChildren === void 0) {
            options.rootIsChildren = Array.isArray(obj);
          }
          if (!_.isString(options.childrenPath) && !Array.isArray(options.childrenPath)) {
            throw Error("childrenPath can be string or array");
          } else {
            if (_.isString(options.childrenPath)) {
              options.childrenPath = [options.childrenPath];
            }
            options.strChildrenPath = options.childrenPath;
            options.childrenPath = [];
            for (var i = options.strChildrenPath.length - 1; i >= 0; i--) {
              options.childrenPath[i] = _.toPath(options.strChildrenPath[i]);
            }
          }
        }
        iterate({
          value: obj,
          callback,
          options,
          obj
        });
        return obj;
      }
      return eachDeep;
    }
    module.exports = getEachDeep;
  }
});

// node_modules/deepdash/getCondenseDeep.js
var require_getCondenseDeep = __commonJS({
  "node_modules/deepdash/getCondenseDeep.js"(exports, module) {
    "use strict";
    var getCondense = require_getCondense();
    var getEachDeep = require_getEachDeep();
    function getCondenseDeep(_) {
      var eachDeep = getEachDeep(_);
      var condense = getCondense();
      var _each = _.each || _.forArray;
      function condenseDeep(obj, options) {
        options = _.merge(
          {
            checkCircular: false
          },
          options || {}
        );
        var eachDeepOptions = {
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly
        };
        var arrays = [];
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.isCircular && Array.isArray(value)) {
              arrays.push(value);
            }
          },
          eachDeepOptions
        );
        if (Array.isArray(obj)) {
          arrays.push(obj);
        }
        _each(arrays, condense);
        return obj;
      }
      return condenseDeep;
    }
    module.exports = getCondenseDeep;
  }
});

// node_modules/deepdash/addCondenseDeep.js
var require_addCondenseDeep = __commonJS({
  "node_modules/deepdash/addCondenseDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getCondenseDeep = require_getCondenseDeep();
    function addCondenseDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("condenseDeep", getCondenseDeep(_), !getCondenseDeep.notChainable);
    }
    module.exports = addCondenseDeep;
  }
});

// node_modules/deepdash/addEachDeep.js
var require_addEachDeep = __commonJS({
  "node_modules/deepdash/addEachDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getEachDeep = require_getEachDeep();
    function addEachDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("eachDeep", getEachDeep(_), !getEachDeep.notChainable);
    }
    module.exports = addEachDeep;
  }
});

// node_modules/deepdash/getExists.js
var require_getExists = __commonJS({
  "node_modules/deepdash/getExists.js"(exports, module) {
    "use strict";
    function getExists(_) {
      function exists(obj, path) {
        path = Array.isArray(path) ? _.clone(path) : _.toPath(path);
        var key = path.pop();
        var parent = path.length ? _.get(obj, path) : obj;
        return parent !== void 0 && key in parent;
      }
      return exists;
    }
    getExists.notChainable = true;
    module.exports = getExists;
  }
});

// node_modules/deepdash/addExists.js
var require_addExists = __commonJS({
  "node_modules/deepdash/addExists.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getExists = require_getExists();
    function addExists(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("exists", getExists(_), !getExists.notChainable);
    }
    module.exports = addExists;
  }
});

// node_modules/deepdash/getFilterDeep.js
var require_getFilterDeep = __commonJS({
  "node_modules/deepdash/getFilterDeep.js"(exports, module) {
    "use strict";
    var getCondense = require_getCondense();
    var isObject = require_isObject();
    var getEachDeep = require_getEachDeep();
    function getFilterDeep(_) {
      var eachDeep = getEachDeep(_);
      var condense = getCondense();
      function filterDeep(obj, predicate, options) {
        predicate = _.iteratee(predicate);
        if (!options) {
          options = {};
        } else {
          options = _.cloneDeep(options);
          if (options.leafsOnly !== void 0) {
            options.leavesOnly = options.leafsOnly;
          }
        }
        if (!options.onTrue) {
          options.onTrue = {};
        }
        if (!options.onFalse) {
          options.onFalse = {};
        }
        if (!options.onUndefined) {
          options.onUndefined = {};
        }
        if (options.childrenPath !== void 0) {
          if (options.onTrue.skipChildren === void 0) {
            options.onTrue.skipChildren = false;
          }
          if (options.onUndefined.skipChildren === void 0) {
            options.onUndefined.skipChildren = false;
          }
          if (options.onFalse.skipChildren === void 0) {
            options.onFalse.skipChildren = false;
          }
          if (options.onTrue.cloneDeep === void 0) {
            options.onTrue.cloneDeep = true;
          }
          if (options.onUndefined.cloneDeep === void 0) {
            options.onUndefined.cloneDeep = true;
          }
          if (options.onFalse.cloneDeep === void 0) {
            options.onFalse.cloneDeep = true;
          }
        }
        options = _.merge(
          {
            checkCircular: false,
            keepCircular: true,
            //replaceCircularBy: <by>,
            leavesOnly: options.childrenPath === void 0,
            condense: true,
            cloneDeep: _.cloneDeep,
            pathFormat: "string",
            onTrue: { skipChildren: true, cloneDeep: true, keepIfEmpty: true },
            onUndefined: {
              skipChildren: false,
              cloneDeep: false,
              keepIfEmpty: false
            },
            onFalse: {
              skipChildren: true,
              cloneDeep: false,
              keepIfEmpty: false
            }
          },
          options
        );
        var eachDeepOptions = {
          pathFormat: options.pathFormat,
          checkCircular: options.checkCircular,
          childrenPath: options.childrenPath,
          includeRoot: options.includeRoot,
          rootIsChildren: options.rootIsChildren,
          ownPropertiesOnly: options.ownPropertiesOnly,
          callbackAfterIterate: true,
          leavesOnly: false
        };
        var resIsArray = Array.isArray(obj);
        var res = resIsArray ? [] : isObject(obj) ? {} : null;
        var toCondense = options.condense ? [] : false;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.afterIterate) {
              context.info._filterDeep = {};
              if (!context.isCircular) {
                var reply = !options.leavesOnly || context.isLeaf ? predicate(value, key, parent, context) : void 0;
                if (!isObject(reply)) {
                  if (reply === void 0) {
                    reply = options.onUndefined;
                  } else if (reply) {
                    reply = options.onTrue;
                  } else {
                    reply = options.onFalse;
                  }
                }
                context.info._filterDeep.reply = reply;
                context.info._filterDeep.empty = reply.empty === void 0 ? true : reply.empty;
                if (reply.keepIfEmpty || !reply.skipChildren) {
                  if (options.cloneDeep && reply.cloneDeep) {
                    if (context.path !== void 0) {
                      var children = takeResultParent(context, res);
                      context.info._filterDeep.res = children[key] = options.cloneDeep(value);
                    } else {
                      context.info._filterDeep.res = res = options.cloneDeep(value);
                    }
                  } else {
                    if (context.path !== void 0) {
                      var children$1 = takeResultParent(context, res);
                      context.info._filterDeep.res = children$1[key] = context.info.isArray ? [] : context.info.isObject ? {} : value;
                    } else {
                      context.info._filterDeep.res = res = context.info.isArray ? [] : context.info.isObject ? {} : value;
                    }
                  }
                }
                return !reply.skipChildren;
              } else {
                var children$2 = takeResultParent(context, res);
                if (!options.keepCircular) {
                  delete children$2[key];
                  if (toCondense && (children$2 === context.parent.info._filterDeep.res && context.parent.info.isArray || Array.isArray(children$2)) && !context.parent.info._filterDeep.isSparse) {
                    context.parent.info._filterDeep.isSparse = true;
                    toCondense.push(context.parent.info);
                  }
                  context.info._filterDeep.excluded = true;
                } else {
                  context.info._filterDeep.res = children$2[key] = "replaceCircularBy" in options ? options.replaceCircularBy : context.circularParent.path !== void 0 ? context.circularParent.info._filterDeep.res : res;
                }
                return false;
              }
            } else if (context.afterIterate && !context.isCircular) {
              var reply$1 = context.info._filterDeep.reply;
              if (context.info._filterDeep.empty && !reply$1.keepIfEmpty) {
                if (context.path === void 0) {
                  res = null;
                } else {
                  var children$3 = takeResultParent(context, res);
                  delete children$3[key];
                  if (toCondense && (children$3 === context.parent.info._filterDeep.res && context.parent.info.isArray || Array.isArray(children$3)) && !context.parent.info._filterDeep.isSparse) {
                    context.parent.info._filterDeep.isSparse = true;
                    toCondense.push(context.parent.info);
                  }
                  context.info._filterDeep.excluded = true;
                }
              } else {
                var parent$1 = context.parent;
                while (parent$1) {
                  if (!parent$1.info._filterDeep.reply) {
                    parent$1.info._filterDeep.reply = options.onUndefined;
                  }
                  if (!parent$1.info._filterDeep.empty) {
                    break;
                  }
                  parent$1.info._filterDeep.empty = false;
                  parent$1 = parent$1.parent;
                }
              }
              return;
            }
          },
          eachDeepOptions
        );
        if (toCondense) {
          for (var i = 0; i < toCondense.length; i++) {
            var info = toCondense[i];
            if (info._filterDeep.isSparse && !info._filterDeep.excluded) {
              condense(info.children);
            }
          }
          if (resIsArray) {
            condense(res);
          }
        }
        if (resIsArray && !res.length && !eachDeepOptions.includeRoot) {
          return null;
        }
        return res;
      }
      return filterDeep;
      function takeResultParent(context, res) {
        if (context.parent.info.children) {
          return context.parent.info.children;
        }
        if (!context.parent.info._filterDeep) {
          context.parent.info._filterDeep = {};
        }
        var parent = context.parent.info._filterDeep.res;
        if (parent === void 0) {
          parent = context.parent.info._filterDeep.res = res;
        }
        if (context._item.childrenPath) {
          var oParent = context.parent.value;
          for (var i = 0; i < context._item.childrenPath.length; i++) {
            var childKey = context._item.childrenPath[i];
            oParent = oParent[childKey];
            if (!parent[childKey]) {
              parent[childKey] = Array.isArray(oParent) ? [] : {};
            }
            parent = parent[childKey];
          }
        }
        context.parent.info.children = parent;
        return parent;
      }
    }
    module.exports = getFilterDeep;
  }
});

// node_modules/deepdash/addFilterDeep.js
var require_addFilterDeep = __commonJS({
  "node_modules/deepdash/addFilterDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFilterDeep = require_getFilterDeep();
    function addFilterDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("filterDeep", getFilterDeep(_), !getFilterDeep.notChainable);
    }
    module.exports = addFilterDeep;
  }
});

// node_modules/deepdash/getFindDeep.js
var require_getFindDeep = __commonJS({
  "node_modules/deepdash/getFindDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getFindDeep(_) {
      var eachDeep = getEachDeep(_);
      function findDeep(obj, predicate, options) {
        predicate = _.iteratee(predicate);
        if (!options) {
          options = {};
        } else {
          options = _.cloneDeep(options);
          if (options.leafsOnly !== void 0) {
            options.leavesOnly = options.leafsOnly;
          }
        }
        options = _.merge(
          {
            checkCircular: false,
            leavesOnly: options.childrenPath === void 0,
            pathFormat: "string"
          },
          options
        );
        var eachDeepOptions = {
          pathFormat: options.pathFormat,
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly,
          childrenPath: options.childrenPath,
          includeRoot: options.includeRoot,
          rootIsChildren: options.rootIsChildren,
          callbackAfterIterate: false,
          leavesOnly: options.leavesOnly
        };
        var res;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (predicate(value, key, parent, context)) {
              res = { value, key, parent, context };
              return context["break"]();
            }
          },
          eachDeepOptions
        );
        return res;
      }
      return findDeep;
    }
    module.exports = getFindDeep;
  }
});

// node_modules/deepdash/addFindDeep.js
var require_addFindDeep = __commonJS({
  "node_modules/deepdash/addFindDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFindDeep = require_getFindDeep();
    function addFindDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("findDeep", getFindDeep(_), !getFindDeep.notChainable);
    }
    module.exports = addFindDeep;
  }
});

// node_modules/deepdash/getFindPathDeep.js
var require_getFindPathDeep = __commonJS({
  "node_modules/deepdash/getFindPathDeep.js"(exports, module) {
    "use strict";
    var getFindDeep = require_getFindDeep();
    function getFindPathDeep(_) {
      var findDeep = getFindDeep(_);
      function findPathDeep(obj, predicate, options) {
        var res = findDeep(obj, predicate, options);
        return res && res.context.path;
      }
      return findPathDeep;
    }
    module.exports = getFindPathDeep;
  }
});

// node_modules/deepdash/addFindPathDeep.js
var require_addFindPathDeep = __commonJS({
  "node_modules/deepdash/addFindPathDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFindPathDeep = require_getFindPathDeep();
    function addFindPathDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("findPathDeep", getFindPathDeep(_), !getFindPathDeep.notChainable);
    }
    module.exports = addFindPathDeep;
  }
});

// node_modules/deepdash/getFindValueDeep.js
var require_getFindValueDeep = __commonJS({
  "node_modules/deepdash/getFindValueDeep.js"(exports, module) {
    "use strict";
    var getFindDeep = require_getFindDeep();
    function getFindValueDeep(_) {
      var findDeep = getFindDeep(_);
      function findValueDeep(obj, predicate, options) {
        var res = findDeep(obj, predicate, options);
        return res && res.value;
      }
      return findValueDeep;
    }
    module.exports = getFindValueDeep;
  }
});

// node_modules/deepdash/addFindValueDeep.js
var require_addFindValueDeep = __commonJS({
  "node_modules/deepdash/addFindValueDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFindValueDeep = require_getFindValueDeep();
    function addFindValueDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("findValueDeep", getFindValueDeep(_), !getFindValueDeep.notChainable);
    }
    module.exports = addFindValueDeep;
  }
});

// node_modules/deepdash/getForEachDeep.js
var require_getForEachDeep = __commonJS({
  "node_modules/deepdash/getForEachDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getForEachDeep(_) {
      return getEachDeep(_);
    }
    module.exports = getForEachDeep;
  }
});

// node_modules/deepdash/addForEachDeep.js
var require_addForEachDeep = __commonJS({
  "node_modules/deepdash/addForEachDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getForEachDeep = require_getForEachDeep();
    function addForEachDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("forEachDeep", getForEachDeep(_), !getForEachDeep.notChainable);
    }
    module.exports = addForEachDeep;
  }
});

// node_modules/deepdash/getIndex.js
var require_getIndex = __commonJS({
  "node_modules/deepdash/getIndex.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getIndex(_) {
      var eachDeep = getEachDeep(_);
      function index(obj, options) {
        options = _.merge(
          {
            checkCircular: false,
            includeCircularPath: true,
            leavesOnly: !options || options.childrenPath === void 0
          },
          options || {}
        );
        if (options && options.leafsOnly !== void 0) {
          options.leavesOnly = options.leafsOnly;
        }
        var eachDeepOptions = {
          pathFormat: "string",
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly,
          includeRoot: options.includeRoot,
          childrenPath: options.childrenPath,
          rootIsChildren: options.rootIsChildren,
          leavesOnly: options.leavesOnly
        };
        var res = {};
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.isCircular || options.includeCircularPath) {
              if (context.path !== void 0) {
                res[context.path] = value;
              }
            }
          },
          eachDeepOptions
        );
        return res;
      }
      return index;
    }
    module.exports = getIndex;
  }
});

// node_modules/deepdash/addIndex.js
var require_addIndex = __commonJS({
  "node_modules/deepdash/addIndex.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getIndex = require_getIndex();
    function addIndex(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("index", getIndex(_), !getIndex.notChainable);
    }
    module.exports = addIndex;
  }
});

// node_modules/deepdash/getPaths.js
var require_getPaths = __commonJS({
  "node_modules/deepdash/getPaths.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getPaths(_) {
      var eachDeep = getEachDeep(_);
      function paths(obj, options) {
        if (options && options.leafsOnly !== void 0) {
          options.leavesOnly = options.leafsOnly;
        }
        options = _.merge(
          {
            checkCircular: false,
            includeCircularPath: true,
            leavesOnly: !options || options.childrenPath === void 0,
            pathFormat: "string"
          },
          options || {}
        );
        var eachDeepOptions = {
          pathFormat: options.pathFormat,
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly,
          includeRoot: options.includeRoot,
          childrenPath: options.childrenPath,
          rootIsChildren: options.rootIsChildren,
          leavesOnly: options.leavesOnly
        };
        var res = [];
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.isCircular || options.includeCircularPath) {
              if (context.path !== void 0) {
                res.push(context.path);
              }
            }
          },
          eachDeepOptions
        );
        return res;
      }
      return paths;
    }
    module.exports = getPaths;
  }
});

// node_modules/deepdash/getKeysDeep.js
var require_getKeysDeep = __commonJS({
  "node_modules/deepdash/getKeysDeep.js"(exports, module) {
    "use strict";
    var getPaths = require_getPaths();
    function getKeysDeep(_) {
      return getPaths(_);
    }
    module.exports = getKeysDeep;
  }
});

// node_modules/deepdash/addKeysDeep.js
var require_addKeysDeep = __commonJS({
  "node_modules/deepdash/addKeysDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getKeysDeep = require_getKeysDeep();
    function addKeysDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("keysDeep", getKeysDeep(_), !getKeysDeep.notChainable);
    }
    module.exports = addKeysDeep;
  }
});

// node_modules/deepdash/getReduceDeep.js
var require_getReduceDeep = __commonJS({
  "node_modules/deepdash/getReduceDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getReduceDeep(_) {
      var eachDeep = getEachDeep(_);
      function reduceDeep(obj, iteratee, accumulator, options) {
        var accumulatorInited = accumulator !== void 0;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!accumulatorInited) {
              accumulator = value;
              accumulatorInited = true;
            } else {
              accumulator = iteratee(accumulator, value, key, parent, context);
            }
          },
          options
        );
        return accumulator;
      }
      return reduceDeep;
    }
    module.exports = getReduceDeep;
  }
});

// node_modules/deepdash/getMapDeep.js
var require_getMapDeep = __commonJS({
  "node_modules/deepdash/getMapDeep.js"(exports, module) {
    "use strict";
    var getReduceDeep = require_getReduceDeep();
    function getMapDeep(_) {
      var reduceDeep = getReduceDeep(_);
      function mapDeep(obj, iteratee, options) {
        iteratee = _.iteratee(iteratee);
        return reduceDeep(
          obj,
          function(acc, value, key, parentValue, context) {
            acc.push(iteratee(value, key, parentValue, context));
            return acc;
          },
          [],
          options
        );
      }
      return mapDeep;
    }
    module.exports = getMapDeep;
  }
});

// node_modules/deepdash/addMapDeep.js
var require_addMapDeep = __commonJS({
  "node_modules/deepdash/addMapDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getMapDeep = require_getMapDeep();
    function addMapDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("mapDeep", getMapDeep(_), !getMapDeep.notChainable);
    }
    module.exports = addMapDeep;
  }
});

// node_modules/deepdash/getMapKeysDeep.js
var require_getMapKeysDeep = __commonJS({
  "node_modules/deepdash/getMapKeysDeep.js"(exports, module) {
    "use strict";
    var getPathToString = require_getPathToString();
    var getEachDeep = require_getEachDeep();
    function getMapKeysDeep(_) {
      var eachDeep = getEachDeep(_);
      var pathToString = getPathToString(_);
      function mapKeysDeep(obj, iteratee, options) {
        if (options === void 0)
          options = {};
        iteratee = _.iteratee(iteratee);
        options.cloneDeep = options.cloneDeep || _.cloneDeep;
        options.callbackAfterIterate = false;
        var newPaths = [];
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (key === void 0) {
              return;
            }
            var newKey = iteratee(value, key, parent, context) + "";
            if (newKey === key) {
              return;
            }
            var oldPath = context.path;
            var oldPathStr = options.pathFormat === "array" ? JSON.stringify(oldPath) : oldPath;
            var newPath = options.pathFormat === "array" ? (context.parent.path || []).concat(
              context.childrenPath || [],
              [newKey]
            ) : pathToString([newKey], context.parent.path, context.childrenPath);
            var newPathStr = options.pathFormat === "array" ? JSON.stringify(newPath) : newPath;
            if (!newPaths[context.depth - 1]) {
              newPaths[context.depth - 1] = [];
            }
            newPaths[context.depth - 1].push({
              oldPath,
              oldPathStr,
              newPath,
              newPathStr
            });
          },
          options
        );
        var res = options.cloneDeep(obj);
        var d = newPaths.length;
        var loop = function() {
          if (!newPaths[d]) {
            return;
          }
          var overwritten = {};
          newPaths[d].forEach(function(ref) {
            var oldPath = ref.oldPath;
            var oldPathStr = ref.oldPathStr;
            var newPath = ref.newPath;
            var newPathStr = ref.newPathStr;
            var value;
            if (Object.prototype.hasOwnProperty.call(overwritten, oldPathStr)) {
              value = overwritten[oldPathStr];
              delete overwritten[oldPathStr];
            } else {
              value = _.get(res, oldPath);
              if (value === void 0 && !_.has(res, oldPath)) {
                return;
              }
              _.unset(res, oldPath);
            }
            if (_.has(res, newPath) && !Object.prototype.hasOwnProperty.call(overwritten, newPathStr)) {
              overwritten[newPathStr] = _.get(res, newPath);
            }
            _.set(res, newPath, value);
          });
        };
        while (d--)
          loop();
        return res;
      }
      return mapKeysDeep;
    }
    module.exports = getMapKeysDeep;
  }
});

// node_modules/deepdash/addMapKeysDeep.js
var require_addMapKeysDeep = __commonJS({
  "node_modules/deepdash/addMapKeysDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getMapKeysDeep = require_getMapKeysDeep();
    function addMapKeysDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("mapKeysDeep", getMapKeysDeep(_), !getMapKeysDeep.notChainable);
    }
    module.exports = addMapKeysDeep;
  }
});

// node_modules/deepdash/getMapValuesDeep.js
var require_getMapValuesDeep = __commonJS({
  "node_modules/deepdash/getMapValuesDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getMapValuesDeep(_) {
      var eachDeep = getEachDeep(_);
      function mapValuesDeep(obj, iteratee, options) {
        iteratee = _.iteratee(iteratee);
        var res = Array.isArray(obj) ? [] : _.isObject(obj) ? {} : _.clone(obj);
        var skipChildren;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            context.skipChildren = function(skip) {
              skipChildren = skip;
            };
            skipChildren = void 0;
            var r = iteratee(value, key, parent, context);
            if (!context.isLeaf && skipChildren === void 0) {
              skipChildren = value !== r && Array.isArray(value) != Array.isArray(r);
            }
            if (context.path !== void 0) {
              _.set(res, context.path, r);
            } else {
              res = r;
            }
            if (skipChildren) {
              return false;
            }
          },
          options
        );
        return res;
      }
      return mapValuesDeep;
    }
    module.exports = getMapValuesDeep;
  }
});

// node_modules/deepdash/addMapValuesDeep.js
var require_addMapValuesDeep = __commonJS({
  "node_modules/deepdash/addMapValuesDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getMapValuesDeep = require_getMapValuesDeep();
    function addMapValuesDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("mapValuesDeep", getMapValuesDeep(_), !getMapValuesDeep.notChainable);
    }
    module.exports = addMapValuesDeep;
  }
});

// node_modules/deepdash/getPathMatches.js
var require_getPathMatches = __commonJS({
  "node_modules/deepdash/getPathMatches.js"(exports, module) {
    "use strict";
    var getPathToString = require_getPathToString();
    function getPathMatches(_) {
      var pathToString = getPathToString(_);
      function pathMatches(path, paths) {
        var pathString;
        var pathArray;
        if (_.isString(path)) {
          pathString = path;
        } else {
          pathArray = path;
        }
        if (!Array.isArray(paths)) {
          paths = [paths];
        } else {
          paths = _.cloneDeep(paths);
        }
        for (var i = 0; i < paths.length; i++) {
          if (_.isString(paths[i])) {
            paths[i] = _.toPath(paths[i]);
          }
          if (Array.isArray(paths[i])) {
            if (pathArray === void 0) {
              pathArray = _.toPath(pathString);
            }
            if (pathArray.length >= paths[i].length && _.isEqual(_.takeRight(pathArray, paths[i].length), paths[i])) {
              return paths[i];
            }
          } else if (paths[i] instanceof RegExp) {
            if (pathString === void 0) {
              pathString = pathToString(path);
            }
            if (paths[i].test(pathString)) {
              return paths[i];
            }
          } else {
            throw new Error(
              "To match path use only string/regex or array of them."
            );
          }
        }
        return false;
      }
      return pathMatches;
    }
    getPathMatches.notChainable = true;
    module.exports = getPathMatches;
  }
});

// node_modules/deepdash/getOmitDeep.js
var require_getOmitDeep = __commonJS({
  "node_modules/deepdash/getOmitDeep.js"(exports, module) {
    "use strict";
    var getFilterDeep = require_getFilterDeep();
    var getPathMatches = require_getPathMatches();
    function getOmitDeep(_) {
      var pathMatches = getPathMatches(_);
      var filterDeep = getFilterDeep(_);
      function omitDeep(obj, paths, options) {
        options = _.merge(
          {
            invert: false
          },
          options || {}
        );
        var isOmit = !options.invert;
        options = _.merge(
          {
            onMatch: {
              cloneDeep: false,
              skipChildren: false,
              keepIfEmpty: !isOmit
            },
            onNotMatch: {
              cloneDeep: false,
              skipChildren: false,
              keepIfEmpty: isOmit
            }
          },
          options
        );
        options.leavesOnly = false;
        options.childrenPath = void 0;
        options.includeRoot = void 0;
        options.pathFormat = "array";
        options.onTrue = options.invert ? options.onMatch : options.onNotMatch;
        options.onFalse = options.invert ? options.onNotMatch : options.onMatch;
        var test = function(value, key, parent, context) {
          if (pathMatches(context.path, paths) !== false) {
            return options.invert;
          } else {
            return !options.invert;
          }
        };
        return filterDeep(obj, test, options);
      }
      return omitDeep;
    }
    module.exports = getOmitDeep;
  }
});

// node_modules/deepdash/addOmitDeep.js
var require_addOmitDeep = __commonJS({
  "node_modules/deepdash/addOmitDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getOmitDeep = require_getOmitDeep();
    function addOmitDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("omitDeep", getOmitDeep(_), !getOmitDeep.notChainable);
    }
    module.exports = addOmitDeep;
  }
});

// node_modules/deepdash/addPathMatches.js
var require_addPathMatches = __commonJS({
  "node_modules/deepdash/addPathMatches.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPathMatches = require_getPathMatches();
    function addPathMatches(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("pathMatches", getPathMatches(_), !getPathMatches.notChainable);
    }
    module.exports = addPathMatches;
  }
});

// node_modules/deepdash/addPathToString.js
var require_addPathToString = __commonJS({
  "node_modules/deepdash/addPathToString.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPathToString = require_getPathToString();
    function addPathToString(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("pathToString", getPathToString(_), !getPathToString.notChainable);
    }
    module.exports = addPathToString;
  }
});

// node_modules/deepdash/addPaths.js
var require_addPaths = __commonJS({
  "node_modules/deepdash/addPaths.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPaths = require_getPaths();
    function addPaths(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("paths", getPaths(_), !getPaths.notChainable);
    }
    module.exports = addPaths;
  }
});

// node_modules/deepdash/getPickDeep.js
var require_getPickDeep = __commonJS({
  "node_modules/deepdash/getPickDeep.js"(exports, module) {
    "use strict";
    var getOmitDeep = require_getOmitDeep();
    function getPickDeep(_) {
      var omitDeep = getOmitDeep(_);
      function pickDeep(obj, paths, options) {
        options = _.merge(
          {
            invert: false
          },
          options || {}
        );
        options.invert = true;
        return omitDeep(obj, paths, options);
      }
      return pickDeep;
    }
    module.exports = getPickDeep;
  }
});

// node_modules/deepdash/addPickDeep.js
var require_addPickDeep = __commonJS({
  "node_modules/deepdash/addPickDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPickDeep = require_getPickDeep();
    function addPickDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("pickDeep", getPickDeep(_), !getPickDeep.notChainable);
    }
    module.exports = addPickDeep;
  }
});

// node_modules/deepdash/addReduceDeep.js
var require_addReduceDeep = __commonJS({
  "node_modules/deepdash/addReduceDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getReduceDeep = require_getReduceDeep();
    function addReduceDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("reduceDeep", getReduceDeep(_), !getReduceDeep.notChainable);
    }
    module.exports = addReduceDeep;
  }
});

// node_modules/deepdash/getSomeDeep.js
var require_getSomeDeep = __commonJS({
  "node_modules/deepdash/getSomeDeep.js"(exports, module) {
    "use strict";
    var getFindDeep = require_getFindDeep();
    function getSomeDeep(_) {
      var findDeep = getFindDeep(_);
      function someDeep(obj, predicate, options) {
        return !!findDeep(obj, predicate, options);
      }
      return someDeep;
    }
    module.exports = getSomeDeep;
  }
});

// node_modules/deepdash/addSomeDeep.js
var require_addSomeDeep = __commonJS({
  "node_modules/deepdash/addSomeDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getSomeDeep = require_getSomeDeep();
    function addSomeDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("someDeep", getSomeDeep(_), !getSomeDeep.notChainable);
    }
    module.exports = addSomeDeep;
  }
});

// node_modules/deepdash/deepdash.js
var require_deepdash = __commonJS({
  "node_modules/deepdash/deepdash.js"(exports, module) {
    "use strict";
    var addCondense = require_addCondense();
    var addCondenseDeep = require_addCondenseDeep();
    var addEachDeep = require_addEachDeep();
    var addExists = require_addExists();
    var addFilterDeep = require_addFilterDeep();
    var addFindDeep = require_addFindDeep();
    var addFindPathDeep = require_addFindPathDeep();
    var addFindValueDeep = require_addFindValueDeep();
    var addForEachDeep = require_addForEachDeep();
    var addIndex = require_addIndex();
    var addKeysDeep = require_addKeysDeep();
    var addMapDeep = require_addMapDeep();
    var addMapKeysDeep = require_addMapKeysDeep();
    var addMapValuesDeep = require_addMapValuesDeep();
    var addOmitDeep = require_addOmitDeep();
    var addPathMatches = require_addPathMatches();
    var addPathToString = require_addPathToString();
    var addPaths = require_addPaths();
    var addPickDeep = require_addPickDeep();
    var addReduceDeep = require_addReduceDeep();
    var addSomeDeep = require_addSomeDeep();
    function apply(_) {
      addCondense(_);
      addCondenseDeep(_);
      addEachDeep(_);
      addExists(_);
      addFilterDeep(_);
      addFindDeep(_);
      addFindPathDeep(_);
      addFindValueDeep(_);
      addForEachDeep(_);
      addIndex(_);
      addKeysDeep(_);
      addMapDeep(_);
      addMapKeysDeep(_);
      addMapValuesDeep(_);
      addOmitDeep(_);
      addPathMatches(_);
      addPathToString(_);
      addPaths(_);
      addPickDeep(_);
      addReduceDeep(_);
      addSomeDeep(_);
      return _;
    }
    module.exports = apply;
  }
});

// node_modules/speakingurl/lib/speakingurl.js
var require_speakingurl = __commonJS({
  "node_modules/speakingurl/lib/speakingurl.js"(exports, module) {
    (function(root) {
      "use strict";
      var charMap = {
        // latin
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "Ae",
        "": "A",
        "": "AE",
        "": "C",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "D",
        "": "N",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "Oe",
        "": "O",
        "": "O",
        "": "U",
        "": "U",
        "": "U",
        "": "Ue",
        "": "U",
        "": "Y",
        "": "TH",
        "": "ss",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "ae",
        "": "a",
        "": "ae",
        "": "c",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "d",
        "": "n",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "oe",
        "": "o",
        "": "o",
        "": "u",
        "": "u",
        "": "u",
        "": "ue",
        "": "u",
        "": "y",
        "": "th",
        "": "y",
        "": "SS",
        // language specific
        // Arabic
        "": "a",
        "": "a",
        "": "i",
        "": "aa",
        "": "u",
        "": "e",
        "": "a",
        "": "b",
        "": "t",
        "": "th",
        "": "j",
        "": "h",
        "": "kh",
        "": "d",
        "": "th",
        "": "r",
        "": "z",
        "": "s",
        "": "sh",
        "": "s",
        "": "dh",
        "": "t",
        "": "z",
        "": "a",
        "": "gh",
        "": "f",
        "": "q",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "h",
        "": "w",
        "": "y",
        "": "a",
        "": "h",
        "": "la",
        "": "laa",
        "": "lai",
        "": "laa",
        // Persian additional characters than Arabic
        "": "g",
        "": "ch",
        "": "p",
        "": "zh",
        "": "k",
        "": "y",
        // Arabic diactrics
        "": "a",
        "": "an",
        "": "e",
        "": "en",
        "": "u",
        "": "on",
        "": "",
        // Arabic numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Persian numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Burmese consonants
        "": "k",
        "": "kh",
        "": "g",
        "": "ga",
        "": "ng",
        "": "s",
        "": "sa",
        "": "z",
        "": "za",
        "": "ny",
        "": "t",
        "": "ta",
        "": "d",
        "": "da",
        "": "na",
        "": "t",
        "": "ta",
        "": "d",
        "": "da",
        "": "n",
        "": "p",
        "": "pa",
        "": "b",
        "": "ba",
        "": "m",
        "": "y",
        "": "ya",
        "": "l",
        "": "w",
        "": "th",
        "": "h",
        "": "la",
        "": "a",
        // consonant character combos
        "": "y",
        "": "ya",
        "": "w",
        "": "yw",
        "": "ywa",
        "": "h",
        // independent vowels
        "": "e",
        "": "-e",
        "": "i",
        "": "-i",
        "": "u",
        "": "-u",
        "": "aw",
        "": "aw",
        "": "aw",
        // numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // virama and tone marks which are silent in transliteration
        "": "",
        "": "",
        "": "",
        // Czech
        "": "c",
        "": "d",
        "": "e",
        "": "n",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "z",
        "": "C",
        "": "D",
        "": "E",
        "": "N",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "Z",
        // Dhivehi
        "": "h",
        "": "sh",
        "": "n",
        "": "r",
        "": "b",
        "": "lh",
        "": "k",
        "": "a",
        "": "v",
        "": "m",
        "": "f",
        "": "dh",
        "": "th",
        "": "l",
        "": "g",
        "": "gn",
        "": "s",
        "": "d",
        "": "z",
        "": "t",
        "": "y",
        "": "p",
        "": "j",
        "": "ch",
        "": "tt",
        "": "hh",
        "": "kh",
        "": "th",
        "": "z",
        "": "sh",
        "": "s",
        "": "d",
        "": "t",
        "": "z",
        "": "a",
        "": "gh",
        "": "q",
        "": "w",
        "": "a",
        "": "aa",
        "": "i",
        "": "ee",
        "": "u",
        "": "oo",
        "": "e",
        "": "ey",
        "": "o",
        "": "oa",
        "": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        "": "a",
        "": "b",
        "": "g",
        "": "d",
        "": "e",
        "": "v",
        "": "z",
        "": "t",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "zh",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "p",
        "": "k",
        "": "gh",
        "": "q",
        "": "sh",
        "": "ch",
        "": "ts",
        "": "dz",
        "": "ts",
        "": "ch",
        "": "kh",
        "": "j",
        "": "h",
        // Greek
        "": "a",
        "": "v",
        "": "g",
        "": "d",
        "": "e",
        "": "z",
        "": "i",
        "": "th",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "ks",
        "": "o",
        "": "p",
        "": "r",
        "": "s",
        "": "t",
        "": "y",
        "": "f",
        "": "x",
        "": "ps",
        "": "o",
        "": "a",
        "": "e",
        "": "i",
        "": "o",
        "": "y",
        "": "i",
        "": "o",
        "": "s",
        "": "i",
        "": "y",
        "": "y",
        "": "i",
        "": "A",
        "": "B",
        "": "G",
        "": "D",
        "": "E",
        "": "Z",
        "": "I",
        "": "TH",
        "": "I",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "KS",
        "": "O",
        "": "P",
        "": "R",
        "": "S",
        "": "T",
        "": "Y",
        "": "F",
        "": "X",
        "": "PS",
        "": "O",
        "": "A",
        "": "E",
        "": "I",
        "": "O",
        "": "Y",
        "": "I",
        "": "O",
        "": "I",
        "": "Y",
        // Latvian
        "": "a",
        // '': 'c', // duplicate
        "": "e",
        "": "g",
        "": "i",
        "": "k",
        "": "l",
        "": "n",
        // '': 's', // duplicate
        "": "u",
        // '': 'z', // duplicate
        "": "A",
        // '': 'C', // duplicate
        "": "E",
        "": "G",
        "": "I",
        "": "k",
        "": "L",
        "": "N",
        // '': 'S', // duplicate
        "": "U",
        // '': 'Z', // duplicate
        // Macedonian
        "": "Kj",
        "": "kj",
        "": "Lj",
        "": "lj",
        "": "Nj",
        "": "nj",
        "": "Ts",
        "": "ts",
        // Polish
        "": "a",
        "": "c",
        "": "e",
        "": "l",
        "": "n",
        // '': 'o', // duplicate
        "": "s",
        "": "z",
        "": "z",
        "": "A",
        "": "C",
        "": "E",
        "": "L",
        "": "N",
        "": "S",
        "": "Z",
        "": "Z",
        // Ukranian
        "": "Ye",
        "": "I",
        "": "Yi",
        "": "G",
        "": "ye",
        "": "i",
        "": "yi",
        "": "g",
        // Romanian
        "": "a",
        "": "A",
        "": "s",
        "": "S",
        // '': 's', // duplicate
        // '': 'S', // duplicate
        "": "t",
        "": "T",
        "": "t",
        "": "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        "": "a",
        "": "b",
        "": "v",
        "": "g",
        "": "d",
        "": "e",
        "": "yo",
        "": "zh",
        "": "z",
        "": "i",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "f",
        "": "kh",
        "": "c",
        "": "ch",
        "": "sh",
        "": "sh",
        "": "",
        "": "y",
        "": "",
        "": "e",
        "": "yu",
        "": "ya",
        "": "A",
        "": "B",
        "": "V",
        "": "G",
        "": "D",
        "": "E",
        "": "Yo",
        "": "Zh",
        "": "Z",
        "": "I",
        "": "I",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "F",
        "": "Kh",
        "": "C",
        "": "Ch",
        "": "Sh",
        "": "Sh",
        "": "",
        "": "Y",
        "": "",
        "": "E",
        "": "Yu",
        "": "Ya",
        // Serbian
        "": "dj",
        "": "j",
        // '': 'lj',  // duplicate
        // '': 'nj', // duplicate
        "": "c",
        "": "dz",
        "": "Dj",
        "": "j",
        // '': 'Lj', // duplicate
        // '': 'Nj', // duplicate
        "": "C",
        "": "Dz",
        // Slovak
        "": "l",
        "": "l",
        "": "r",
        "": "L",
        "": "L",
        "": "R",
        // Turkish
        "": "s",
        "": "S",
        "": "i",
        "": "I",
        // '': 'c', // duplicate
        // '': 'C', // duplicate
        // '': 'u', // duplicate, see langCharMap
        // '': 'U', // duplicate, see langCharMap
        // '': 'o', // duplicate, see langCharMap
        // '': 'O', // duplicate, see langCharMap
        "": "g",
        "": "G",
        // Vietnamese
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "d",
        "": "D",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "o",
        "": "i",
        "": "I",
        "": "i",
        "": "I",
        "": "i",
        "": "i",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "",
        "": "y",
        "": "y",
        "": "y",
        "": "Y",
        "": "y",
        "": "Y",
        "": "y",
        "": "Y",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        // '': 'a', // duplicate
        // '': 'A', // duplicate
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "18",
        "": "18",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "0",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "19",
        "": "20",
        "": "A",
        "": "B",
        "": "C",
        "": "D",
        "": "E",
        "": "F",
        "": "G",
        "": "H",
        "": "I",
        "": "J",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "Q",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "V",
        "": "W",
        "": "X",
        "": "Y",
        "": "Z",
        "": "a",
        "": "b",
        "": "c",
        "": "d",
        "": "e",
        "": "f",
        "": "g",
        "": "h",
        "": "i",
        "": "j",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "q",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "v",
        "": "w",
        "": "x",
        "": "y",
        "": "z",
        // symbols
        "": '"',
        "": '"',
        "": "'",
        "": "'",
        "": "d",
        "": "f",
        "": "(TM)",
        "": "(C)",
        "": "oe",
        "": "OE",
        "": "(R)",
        "": "+",
        "": "(SM)",
        "": "...",
        "": "o",
        "": "o",
        "": "a",
        "": "*",
        "": ",",
        "": ".",
        // currency
        "$": "USD",
        "": "EUR",
        "": "BRN",
        "": "FRF",
        "": "GBP",
        "": "ITL",
        "": "NGN",
        "": "ESP",
        "": "KRW",
        "": "ILS",
        "": "VND",
        "": "LAK",
        "": "MNT",
        "": "GRD",
        "": "ARS",
        "": "PYG",
        "": "ARA",
        "": "UAH",
        "": "GHS",
        "": "cent",
        "": "CNY",
        "": "CNY",
        "": "YEN",
        "": "IRR",
        "": "EWE",
        "": "THB",
        "": "INR",
        "": "INR",
        "": "PF",
        "": "TRY",
        "": "AFN",
        "": "AZN",
        "": "BGN",
        "": "KHR",
        "": "CRC",
        "": "KZT",
        "": "MKD",
        "z": "PLN",
        "": "RUB",
        "": "GEL"
      };
      var lookAheadCharArray = [
        // burmese
        "",
        // Dhivehi
        ""
      ];
      var diatricMap = {
        // Burmese
        // dependent vowels
        "": "a",
        "": "a",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "o",
        "": "u",
        "": "u",
        "": "aung",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "",
        // this is special case but the character will be converted to latin in the code
        "": "et",
        "": "aik",
        "": "auk",
        "": "in",
        "": "aing",
        "": "aung",
        "": "it",
        "": "i",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "it",
        "": "d",
        "": "ok",
        "": "ait",
        "": "an",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "nub",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "e",
        "": "ol",
        "": "in",
        "": "an",
        "": "ein",
        "": "on",
        // Dhivehi
        "": "ah",
        "": "ah"
      };
      var langCharMap = {
        "en": {},
        // default language
        "az": {
          // Azerbaijani
          "": "c",
          "": "e",
          "": "g",
          "": "i",
          "": "o",
          "": "s",
          "": "u",
          "": "C",
          "": "E",
          "": "G",
          "": "I",
          "": "O",
          "": "S",
          "": "U"
        },
        "cs": {
          // Czech
          "": "c",
          "": "d",
          "": "e",
          "": "n",
          "": "r",
          "": "s",
          "": "t",
          "": "u",
          "": "z",
          "": "C",
          "": "D",
          "": "E",
          "": "N",
          "": "R",
          "": "S",
          "": "T",
          "": "U",
          "": "Z"
        },
        "fi": {
          // Finnish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "a",
          // ok
          "": "A",
          // ok
          "": "o",
          // ok
          "": "O"
          // ok
        },
        "hu": {
          // Hungarian
          "": "a",
          // ok
          "": "A",
          // ok
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "o",
          // ok
          "": "O",
          // ok
          // '': 'o', duplicate see charMap/latin
          // '': 'O', duplicate see charMap/latin
          "": "u",
          "": "U",
          "": "u",
          "": "U"
        },
        "lt": {
          // Lithuanian
          "": "a",
          "": "c",
          "": "e",
          "": "e",
          "": "i",
          "": "s",
          "": "u",
          "": "u",
          "": "z",
          "": "A",
          "": "C",
          "": "E",
          "": "E",
          "": "I",
          "": "S",
          "": "U",
          "": "U"
        },
        "lv": {
          // Latvian
          "": "a",
          "": "c",
          "": "e",
          "": "g",
          "": "i",
          "": "k",
          "": "l",
          "": "n",
          "": "s",
          "": "u",
          "": "z",
          "": "A",
          "": "C",
          "": "E",
          "": "G",
          "": "i",
          "": "k",
          "": "L",
          "": "N",
          "": "S",
          "": "u",
          "": "Z"
        },
        "pl": {
          // Polish
          "": "a",
          "": "c",
          "": "e",
          "": "l",
          "": "n",
          "": "o",
          "": "s",
          "": "z",
          "": "z",
          "": "A",
          "": "C",
          "": "e",
          "": "L",
          "": "N",
          "": "O",
          "": "S",
          "": "Z",
          "": "Z"
        },
        "sv": {
          // Swedish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "a",
          // ok
          "": "A",
          // ok
          "": "o",
          // ok
          "": "O"
          // ok
        },
        "sk": {
          // Slovak
          "": "a",
          "": "A"
        },
        "sr": {
          // Serbian
          "": "lj",
          "": "nj",
          "": "Lj",
          "": "Nj",
          "": "dj",
          "": "Dj"
        },
        "tr": {
          // Turkish
          "": "U",
          "": "O",
          "": "u",
          "": "o"
        }
      };
      var symbolMap = {
        "ar": {
          "": "delta",
          "": "la-nihaya",
          "": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "": "majmou",
          "": "omla"
        },
        "az": {},
        "ca": {
          "": "delta",
          "": "infinit",
          "": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "": "suma dels",
          "": "moneda"
        },
        "cs": {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "": "soucet",
          "": "mena"
        },
        "de": {
          "": "delta",
          "": "unendlich",
          "": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "": "Summe von",
          "": "Waehrung"
        },
        "dv": {
          "": "delta",
          "": "kolunulaa",
          "": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "": "jumula",
          "": "faisaa"
        },
        "en": {
          "": "delta",
          "": "infinity",
          "": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "": "sum",
          "": "currency"
        },
        "es": {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "": "suma de los",
          "": "moneda"
        },
        "fa": {
          "": "delta",
          "": "bi-nahayat",
          "": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "": "majmooe",
          "": "vahed"
        },
        "fi": {
          "": "delta",
          "": "aarettomyys",
          "": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "": "summa",
          "": "valuutta"
        },
        "fr": {
          "": "delta",
          "": "infiniment",
          "": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "": "somme des",
          "": "monnaie"
        },
        "ge": {
          "": "delta",
          "": "usasruloba",
          "": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "": "jami",
          "": "valuta"
        },
        "gr": {},
        "hu": {
          "": "delta",
          "": "vegtelen",
          "": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "": "szumma",
          "": "penznem"
        },
        "it": {
          "": "delta",
          "": "infinito",
          "": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "": "somma",
          "": "moneta"
        },
        "lt": {
          "": "delta",
          "": "begalybe",
          "": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "": "suma",
          "": "valiuta"
        },
        "lv": {
          "": "delta",
          "": "bezgaliba",
          "": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "": "summa",
          "": "valuta"
        },
        "my": {
          "": "kwahkhyaet",
          "": "asaonasme",
          "": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "": "paungld",
          "": "ngwekye"
        },
        "mk": {},
        "nl": {
          "": "delta",
          "": "oneindig",
          "": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "": "som",
          "": "valuta"
        },
        "pl": {
          "": "delta",
          "": "nieskonczonosc",
          "": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "": "suma",
          "": "waluta"
        },
        "pt": {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "": "soma",
          "": "moeda"
        },
        "ro": {
          "": "delta",
          "": "infinit",
          "": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "": "suma",
          "": "valuta"
        },
        "ru": {
          "": "delta",
          "": "beskonechno",
          "": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "": "summa",
          "": "valjuta"
        },
        "sk": {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "": "sucet",
          "": "mena"
        },
        "sr": {},
        "tr": {
          "": "delta",
          "": "sonsuzluk",
          "": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "": "toplam",
          "": "para birimi"
        },
        "uk": {
          "": "delta",
          "": "bezkinechnist",
          "": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "": "suma",
          "": "valjuta"
        },
        "vn": {
          "": "delta",
          "": "vo cuc",
          "": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "": "tong",
          "": "tien te"
        }
      };
      var uricChars = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join("");
      var uricNoSlashChars = [";", "?", ":", "@", "&", "=", "+", "$", ","].join("");
      var markChars = [".", "!", "~", "*", "'", "(", ")"].join("");
      var getSlug = function getSlug2(input, opts) {
        var separator = "-";
        var result = "";
        var diatricString = "";
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = "";
        if (typeof input !== "string") {
          return "";
        }
        if (typeof opts === "string") {
          separator = opts;
        }
        symbol = symbolMap.en;
        langChar = langCharMap.en;
        if (typeof opts === "object") {
          maintainCase = opts.maintainCase || false;
          customReplacements = opts.custom && typeof opts.custom === "object" ? opts.custom : customReplacements;
          truncate = +opts.truncate > 1 && opts.truncate || false;
          uricFlag = opts.uric || false;
          uricNoSlashFlag = opts.uricNoSlash || false;
          markFlag = opts.mark || false;
          convertSymbols = opts.symbols === false || opts.lang === false ? false : true;
          separator = opts.separator || separator;
          if (uricFlag) {
            allowedChars += uricChars;
          }
          if (uricNoSlashFlag) {
            allowedChars += uricNoSlashChars;
          }
          if (markFlag) {
            allowedChars += markChars;
          }
          symbol = opts.lang && symbolMap[opts.lang] && convertSymbols ? symbolMap[opts.lang] : convertSymbols ? symbolMap.en : {};
          langChar = opts.lang && langCharMap[opts.lang] ? langCharMap[opts.lang] : opts.lang === false || opts.lang === true ? {} : langCharMap.en;
          if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {
            opts.titleCase.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
            titleCase = true;
          } else {
            titleCase = !!opts.titleCase;
          }
          if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {
            opts.custom.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
          }
          Object.keys(customReplacements).forEach(function(v) {
            var r;
            if (v.length > 1) {
              r = new RegExp("\\b" + escapeChars(v) + "\\b", "gi");
            } else {
              r = new RegExp(escapeChars(v), "gi");
            }
            input = input.replace(r, customReplacements[v]);
          });
          for (ch in customReplacements) {
            allowedChars += ch;
          }
        }
        allowedChars += separator;
        allowedChars = escapeChars(allowedChars);
        input = input.replace(/(^\s+|\s+$)/g, "");
        lastCharWasSymbol = false;
        lastCharWasDiatric = false;
        for (i = 0, l = input.length; i < l; i++) {
          ch = input[i];
          if (isReplacedCustomChar(ch, customReplacements)) {
            lastCharWasSymbol = false;
          } else if (langChar[ch]) {
            ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? " " + langChar[ch] : langChar[ch];
            lastCharWasSymbol = false;
          } else if (ch in charMap) {
            if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
              diatricString += ch;
              ch = "";
            } else if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + charMap[ch];
              diatricString = "";
            } else {
              ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? " " + charMap[ch] : charMap[ch];
            }
            lastCharWasSymbol = false;
            lastCharWasDiatric = false;
          } else if (ch in diatricMap) {
            diatricString += ch;
            ch = "";
            if (i === l - 1) {
              ch = diatricMap[diatricString];
            }
            lastCharWasDiatric = true;
          } else if (
            // process symbol chars
            symbol[ch] && !(uricFlag && uricChars.indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.indexOf(ch) !== -1)
          ) {
            ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
            ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : "";
            lastCharWasSymbol = true;
          } else {
            if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + ch;
              diatricString = "";
              lastCharWasDiatric = false;
            } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
              ch = " " + ch;
            }
            lastCharWasSymbol = false;
          }
          result += ch.replace(new RegExp("[^\\w\\s" + allowedChars + "_-]", "g"), separator);
        }
        if (titleCase) {
          result = result.replace(/(\w)(\S*)/g, function(_, i2, r) {
            var j = i2.toUpperCase() + (r !== null ? r : "");
            return Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0 ? j : j.toLowerCase();
          });
        }
        result = result.replace(/\s+/g, separator).replace(new RegExp("\\" + separator + "+", "g"), separator).replace(new RegExp("(^\\" + separator + "+|\\" + separator + "+$)", "g"), "");
        if (truncate && result.length > truncate) {
          lucky = result.charAt(truncate) === separator;
          result = result.slice(0, truncate);
          if (!lucky) {
            result = result.slice(0, result.lastIndexOf(separator));
          }
        }
        if (!maintainCase && !titleCase) {
          result = result.toLowerCase();
        }
        return result;
      };
      var createSlug = function createSlug2(opts) {
        return function getSlugWithConfig(input) {
          return getSlug(input, opts);
        };
      };
      var escapeChars = function escapeChars2(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      };
      var isReplacedCustomChar = function(ch, customReplacements) {
        for (var c in customReplacements) {
          if (customReplacements[c] === ch) {
            return true;
          }
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return getSlug;
        });
      } else {
        try {
          if (root.getSlug || root.createSlug) {
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          } else {
            root.getSlug = getSlug;
            root.createSlug = createSlug;
          }
        } catch (e) {
        }
      }
    })(exports);
  }
});

// node_modules/speakingurl/index.js
var require_speakingurl2 = __commonJS({
  "node_modules/speakingurl/index.js"(exports, module) {
    module.exports = require_speakingurl();
  }
});

// node_modules/shortid/lib/random/random-from-seed.js
var require_random_from_seed = __commonJS({
  "node_modules/shortid/lib/random/random-from-seed.js"(exports, module) {
    "use strict";
    var seed = 1;
    function getNextValue() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }
    function setSeed(_seed_) {
      seed = _seed_;
    }
    module.exports = {
      nextValue: getNextValue,
      seed: setSeed
    };
  }
});

// node_modules/shortid/lib/alphabet.js
var require_alphabet = __commonJS({
  "node_modules/shortid/lib/alphabet.js"(exports, module) {
    "use strict";
    var randomFromSeed = require_random_from_seed();
    var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    var alphabet;
    var previousSeed;
    var shuffled;
    function reset() {
      shuffled = false;
    }
    function setCharacters(_alphabet_) {
      if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
          alphabet = ORIGINAL;
          reset();
        }
        return;
      }
      if (_alphabet_ === alphabet) {
        return;
      }
      if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
      }
      var unique = _alphabet_.split("").filter(function(item, ind, arr) {
        return ind !== arr.lastIndexOf(item);
      });
      if (unique.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
      }
      alphabet = _alphabet_;
      reset();
    }
    function characters(_alphabet_) {
      setCharacters(_alphabet_);
      return alphabet;
    }
    function setSeed(seed) {
      randomFromSeed.seed(seed);
      if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
      }
    }
    function shuffle() {
      if (!alphabet) {
        setCharacters(ORIGINAL);
      }
      var sourceArray = alphabet.split("");
      var targetArray = [];
      var r = randomFromSeed.nextValue();
      var characterIndex;
      while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
      }
      return targetArray.join("");
    }
    function getShuffled() {
      if (shuffled) {
        return shuffled;
      }
      shuffled = shuffle();
      return shuffled;
    }
    function lookup(index) {
      var alphabetShuffled = getShuffled();
      return alphabetShuffled[index];
    }
    function get() {
      return alphabet || ORIGINAL;
    }
    module.exports = {
      get,
      characters,
      seed: setSeed,
      lookup,
      shuffled: getShuffled
    };
  }
});

// node_modules/shortid/lib/random/random-byte-browser.js
var require_random_byte_browser = __commonJS({
  "node_modules/shortid/lib/random/random-byte-browser.js"(exports, module) {
    "use strict";
    var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
    var randomByte;
    if (!crypto || !crypto.getRandomValues) {
      randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
          bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
      };
    } else {
      randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
      };
    }
    module.exports = randomByte;
  }
});

// node_modules/shortid/node_modules/nanoid/format.browser.js
var require_format_browser = __commonJS({
  "node_modules/shortid/node_modules/nanoid/format.browser.js"(exports, module) {
    module.exports = function(random, alphabet, size) {
      var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      var step = -~(1.6 * mask * size / alphabet.length);
      var id = "";
      while (true) {
        var bytes = random(step);
        var i = step;
        while (i--) {
          id += alphabet[bytes[i] & mask] || "";
          if (id.length === +size)
            return id;
        }
      }
    };
  }
});

// node_modules/shortid/lib/generate.js
var require_generate = __commonJS({
  "node_modules/shortid/lib/generate.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var random = require_random_byte_browser();
    var format = require_format_browser();
    function generate(number) {
      var loopCounter = 0;
      var done;
      var str = "";
      while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < Math.pow(16, loopCounter + 1);
        loopCounter++;
      }
      return str;
    }
    module.exports = generate;
  }
});

// node_modules/shortid/lib/build.js
var require_build = __commonJS({
  "node_modules/shortid/lib/build.js"(exports, module) {
    "use strict";
    var generate = require_generate();
    var alphabet = require_alphabet();
    var REDUCE_TIME = 1567752802062;
    var version = 7;
    var counter;
    var previousSeconds;
    function build(clusterWorkerId) {
      var str = "";
      var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
      if (seconds === previousSeconds) {
        counter++;
      } else {
        counter = 0;
        previousSeconds = seconds;
      }
      str = str + generate(version);
      str = str + generate(clusterWorkerId);
      if (counter > 0) {
        str = str + generate(counter);
      }
      str = str + generate(seconds);
      return str;
    }
    module.exports = build;
  }
});

// node_modules/shortid/lib/is-valid.js
var require_is_valid = __commonJS({
  "node_modules/shortid/lib/is-valid.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    function isShortId(id) {
      if (!id || typeof id !== "string" || id.length < 6) {
        return false;
      }
      var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
      return !nonAlphabetic.test(id);
    }
    module.exports = isShortId;
  }
});

// node_modules/shortid/lib/util/cluster-worker-id-browser.js
var require_cluster_worker_id_browser = __commonJS({
  "node_modules/shortid/lib/util/cluster-worker-id-browser.js"(exports, module) {
    "use strict";
    module.exports = 0;
  }
});

// node_modules/shortid/lib/index.js
var require_lib = __commonJS({
  "node_modules/shortid/lib/index.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var build = require_build();
    var isValid = require_is_valid();
    var clusterWorkerId = require_cluster_worker_id_browser() || 0;
    function seed(seedValue) {
      alphabet.seed(seedValue);
      return module.exports;
    }
    function worker(workerId) {
      clusterWorkerId = workerId;
      return module.exports;
    }
    function characters(newCharacters) {
      if (newCharacters !== void 0) {
        alphabet.characters(newCharacters);
      }
      return alphabet.shuffled();
    }
    function generate() {
      return build(clusterWorkerId);
    }
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.isValid = isValid;
  }
});

// node_modules/shortid/index.js
var require_shortid = __commonJS({
  "node_modules/shortid/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/mongoose-slug-updater/lib/slug-generator.js
var require_slug_generator = __commonJS({
  "node_modules/mongoose-slug-updater/lib/slug-generator.js"(exports, module) {
    var _ = require_deepdash()(require_lodash());
    var getSlug = require_speakingurl2();
    var shortId = require_shortid();
    module.exports = function plugin(schema, options) {
      options = _.merge(
        {
          separator: "-",
          lang: "en",
          truncate: 120,
          backwardCompatible: true
        },
        options
      );
      const slugs = [];
      function schemaTraversal(schema2, basePath, cb) {
        if (basePath)
          basePath += ".";
        schema2.eachPath((schemaPath, schemaType) => {
          if (schemaType.caster && schemaType.caster.schema) {
            schemaTraversal(
              schemaType.caster.schema,
              basePath + schemaPath + (schemaType.constructor.schemaName == "DocumentArray" ? ".$" : ""),
              cb
            );
          } else {
            cb(basePath + schemaPath, schemaType);
          }
        });
      }
      function renameOldOptions(opts) {
        if (!options.backwardCompatible)
          return opts;
        const res = _.cloneDeep(opts);
        const deprecated = ["unique_slug", "slug_padding_size"];
        const found = [];
        _.each(deprecated, (oldo) => {
          if (res[oldo] !== void 0) {
            const newo = _.camelCase(oldo);
            found.push([oldo, newo]);
            res[newo] = res[oldo];
            delete res[oldo];
          }
        });
        if (found.length) {
          console.log(
            'Deprecated "snake_case" options found by slug updater plugin. Please update to camelCase.',
            found
          );
        }
        if (res.uniqueGroup) {
          res.uniqueGroupSlug = res.uniqueGroup;
          delete res.uniqueGroup;
          console.log(
            'Deprecated option "uniqueGroup" found by slug updater. Please update to uniqueGroupSlug.'
          );
        }
        if (res.force_id) {
          res.forceIdSlug = res.force_id;
          delete res.force_id;
          console.log(
            'Deprecated option "force_id" found by slug updater. Please update to forceIdSlug.'
          );
        }
        if (res.on) {
          res.slugOn = res.on;
          delete res.on;
          console.log('Deprecated option "on" found by slug updater. Please update to slugOn.');
        }
        return res;
      }
      schemaTraversal(schema, "", (schemaPath, schemaType) => {
        if (schemaType.instance == "String" && schemaType.options && schemaType.options.slug) {
          const opts = renameOldOptions(schemaType.options);
          let basePath = schemaPath.replace(/[.][^.]+$/, "");
          if (basePath === schemaPath)
            basePath = "";
          const slug = {
            path: schemaPath,
            basePath,
            on: {
              save: true,
              update: true,
              updateOne: true,
              updateMany: true,
              findOneAndUpdate: true,
              ...opts.slugOn || {}
            }
          };
          if (typeof opts.slug === "string") {
            slug.fields = [opts.slug];
          } else if (opts.slug instanceof Array) {
            slug.fields = opts.slug;
          } else {
            console.warn(
              `slug option expected to be string or array. ${typeof opts.slug} found and will be ignored.`
            );
            return;
          }
          if (opts.unique || opts.uniqueSlug) {
            slug.unique = true;
          }
          if (opts.permanent) {
            slug.permanent = true;
          }
          if (opts.slugPaddingSize === void 0) {
            slug.isShortIdMode = true;
          } else {
            slug.isShortIdMode = false;
            slug.padding = opts.slugPaddingSize;
          }
          if (opts.uniqueGroupSlug) {
            if (_.isArray(opts.uniqueGroupSlug)) {
              slug.uniqueGroupFields = opts.uniqueGroupSlug;
            } else {
              slug.uniqueGroupFields = [opts.uniqueGroupSlug];
            }
          }
          if (opts.forceIdSlug) {
            slug.unique = true;
            slug.isShortIdMode = true;
            slug.forceShortId = true;
          }
          if (opts.transform) {
            slug.transform = opts.transform;
          }
          slugs.push(slug);
        }
      });
      schema.pre("update", async function() {
        return onUpdate.bind(this)("update");
      });
      schema.pre("updateOne", async function() {
        return onUpdate.bind(this)("updateOne");
      });
      schema.pre("updateMany", async function() {
        return onUpdate.bind(this)("updateMany");
      });
      schema.pre("findOneAndUpdate", async function() {
        return onUpdate.bind(this)("findOneAndUpdate");
      });
      async function onUpdate(operation) {
        const me = this;
        const upd = me.getUpdate();
        const doc = _.cloneDeep(upd);
        if (doc.$set) {
          _.forOwn(doc.$set, (v, k) => {
            _.set(doc, k, v);
          });
          delete doc.$set;
        }
        const docs = [_.cloneDeep(doc)];
        const unwoundSlugs = unwindSlugs(doc, _.filter(slugs, `on.${operation}`));
        if (!unwoundSlugs.length) {
          return;
        }
        const updFields = _.keysDeep(doc);
        const involvedPaths = _.uniq(
          unwoundSlugs.reduce((acc, slug) => acc.concat(slug.fields).concat([slug.path]), [])
        ).map((p) => p.replace(/^\//, ""));
        let involvedValuesDocs = await me.model[operation == "updateOne" ? "findOne" : "find"](
          me.getQuery(),
          _(involvedPaths).map((k) => [k.replace(/\.[$\d]+\./g, "."), 1]).fromPairs().value()
        );
        if (involvedValuesDocs) {
          if (!_.isArray(involvedValuesDocs))
            involvedValuesDocs = [involvedValuesDocs];
          involvedValuesDocs.forEach((freshDoc, i) => {
            if (i)
              docs[i] = _.cloneDeep(doc);
            involvedPaths.forEach((f) => {
              const fs = unwindPath(freshDoc, f);
              _.each(fs, (f2) => {
                if (_.get(docs[i], f2) === void 0)
                  _.set(docs[i], f2, _.get(freshDoc, f2));
              });
            });
            if (freshDoc && freshDoc._id)
              docs[i]._id = freshDoc._id;
          });
        }
        const slugsUpd = [];
        const cache = {};
        async function findOne(query, sort) {
          let res = me.model.findOne(query);
          if (sort) {
            res = res.sort(sort);
          }
          return res;
        }
        for (let i = 0; i < docs.length; i++) {
          const currentUnwoundFields = unwindSlugs(docs[i], unwoundSlugs);
          let actualSlugs = currentUnwoundFields;
          if (involvedValuesDocs && involvedValuesDocs.length) {
            const actualUpdFields = _(updFields).filter((f) => _.get(doc, f) != _.get(involvedValuesDocs[i], f)).map((f) => _.trim(f.replace(/\["?(.+?)"?\]/g, ".$1"), ".")).value();
            actualSlugs = _.filter(
              currentUnwoundFields,
              (s) => _.intersection(
                _.map(s.fields.concat(s.uniqueGroupFields || []), (p) => p.replace(/^\//, "")),
                actualUpdFields
              ).length
            );
          }
          if (actualSlugs.length) {
            await setSlugs(docs[i], actualSlugs, options, findOne, cache);
          }
          slugsUpd[i] = {};
          const origUpd = _.reduce(
            upd.$set,
            (r, v, k) => {
              _.set(r, k, v);
              return r;
            },
            {}
          ) || upd;
          actualSlugs.forEach((slug) => {
            const slugVal = _.get(docs[i], slug.path);
            if (slugVal !== void 0)
              _.set(slugsUpd[i], slug.path, slugVal);
          });
          if (involvedValuesDocs && involvedValuesDocs.length) {
            _.each(currentUnwoundFields, (us) => {
              if (!_.has(origUpd, us.path) && !_.has(slugsUpd[i], us.path)) {
                const val = _.get(involvedValuesDocs[i], us.path);
                if (val !== void 0)
                  _.set(slugsUpd[i], us.path, val);
              }
            });
          }
          let doUpd = slugsUpd[i];
          if (upd.$set) {
            const slugPaths = _(doUpd).index({ leafsOnly: true }).mapKeys((v, f) => _.trim(f.replace(/\["?(.+?)"?\]/g, ".$1"), ".")).omitBy((v) => v === void 0).value();
            doUpd = { $set: slugPaths };
          }
          if (docs.length == 1) {
            if (doUpd)
              me[operation]({}, _.merge(me.getUpdate(), doUpd));
          } else {
            if (doUpd) {
              await me.model.updateOne({ _id: docs[i]._id }, doUpd);
            }
          }
        }
      }
      schema.pre("save", async function() {
        const cache = {};
        let doc = this;
        if (!doc.model) {
          return;
        }
        const reSlug = false;
        const unwoundSlugs = unwindSlugs(doc, _.filter(slugs, "on.save"));
        if (!unwoundSlugs.length) {
          return;
        }
        doc = await setSlugs(
          doc,
          unwoundSlugs,
          options,
          async (query, sort) => {
            let res = doc.model(doc.constructor.modelName).findOne(query);
            if (sort)
              res = res.sort(sort);
            return res;
          },
          cache
        );
      });
    };
    function updateUpdCache(cache, path, slug, value, group) {
      const maskedPath = path.replace(/\.[$\d]+\./g, ".$.");
      const isArrayPath = path != maskedPath;
      const localKey = `${maskedPath}:${slug}`;
      if (isArrayPath) {
        cache.lock[path].ext.resolveEx(value);
        delete cache.lock[path];
      } else {
        const key = `${localKey}-${JSON.stringify(group)}`;
        cache.db[key] = value;
      }
    }
    async function findSame(cache, doc, group, path, slug, isCounter, options, findOne, permanent) {
      cache = _.merge(cache, { db: {}, unwind: {}, upd: {}, lock: {} });
      const maskedPath = path.replace(/\.[$\d]+\./g, ".$.");
      const isArrayPath = path != maskedPath;
      const slugRx = new RegExp(`^${slug}(${options.separator}${isCounter ? "(\\d+)" : "(.+)"})?$`);
      const localKey = `${maskedPath}:${slug}`;
      const key = `${localKey}-${JSON.stringify(group)}`;
      if (isArrayPath) {
        const ext = { path };
        const updPromise = new Promise((resolve, reject) => {
          ext.resolveEx = resolve;
          ext.rejectEx = reject;
        });
        updPromise.ext = ext;
        if (cache.upd[localKey] !== void 0) {
          let res = cache.upd[localKey];
          cache.upd[localKey] = updPromise;
          const fromPath = res.ext.path;
          cache.lock[path] = updPromise;
          res = await res;
          return res;
        }
        cache.upd[localKey] = updPromise;
        cache.lock[path] = updPromise;
      }
      let query = _.cloneDeep(group);
      const sort = {};
      if (cache.db[key] === void 0) {
        const arrayPath = path.replace(/\.[$\d]+\./g, ".");
        query[arrayPath] = slugRx;
        if (doc._id) {
          if (query._id == void 0) {
            query._id = {
              $ne: doc._id
            };
          } else if (!permanent) {
            query = false;
          }
        }
        if (query !== false) {
          if (isCounter)
            sort[arrayPath] = -1;
          cache.db[key] = findOne(query, sort);
        } else {
          cache.db[key] = null;
        }
      }
      if (_.isObject(cache.db[key]) && _.isFunction(cache.db[key].then)) {
        let foundDoc = await cache.db[key];
        if (_.isObject(cache.db[key]) && _.isFunction(cache.db[key].then)) {
          if (!foundDoc) {
            cache.db[key] = null;
          } else {
            foundDoc = _(unwindPath(foundDoc, maskedPath)).map((p) => [p, docGet(foundDoc, p)]).filter(([p, v]) => v.match(slugRx)).sortBy("[1]").last();
            cache.db[key] = foundDoc[1];
          }
        }
      }
      return cache.db[key];
    }
    var docGet = (doc, path) => {
      return _.isFunction(doc.get) ? doc.get(path) : _.get(doc, path);
    };
    var docSet = (doc, path, val) => _.isFunction(doc.set) ? doc.set(path, val) : _.set(doc, path, val);
    var docIsModified = (doc, path) => _.isFunction(doc.isModified) ? doc.isModified(path) : _.get(doc, path) !== void 0;
    function unwindSlugs(doc, slugs) {
      const unwoundSlugs = [];
      slugs.forEach((slug) => {
        const slugPaths = unwindPath(doc, slug.path);
        if (!slugPaths.length)
          slugPaths.push(slug.path);
        let { basePath } = slug;
        if (_.endsWith(basePath, ".$"))
          basePath += ".";
        slugPaths.forEach((slugPath) => {
          let unwoundBasePath = slugPath.replace(/\.[^\.]+$/, "");
          if (unwoundBasePath == slugPath)
            unwoundBasePath = "";
          function unwindFieldPath(fieldPath) {
            let slugValueBasePath = unwoundBasePath;
            let originalBasePath = _.trimEnd(basePath, ".");
            while (_.startsWith(fieldPath, ":")) {
              let prevValueBasePath = slugValueBasePath;
              let prevOriginalBasePath = originalBasePath;
              if (slugValueBasePath.match(/\.[$\d]+$/)) {
                slugValueBasePath = slugValueBasePath.replace(/\.[$\d]+$/, "");
                prevValueBasePath = slugValueBasePath;
              }
              if (originalBasePath.match(/\.[$\d]+$/)) {
                originalBasePath = originalBasePath.replace(/\.[$\d]+$/, "");
                prevOriginalBasePath = originalBasePath;
              }
              slugValueBasePath = slugValueBasePath.replace(/\.[^\.]+$/, "");
              originalBasePath = originalBasePath.replace(/\.[^\.]+$/, "");
              if (slugValueBasePath == prevValueBasePath)
                slugValueBasePath = "";
              if (originalBasePath == prevOriginalBasePath)
                originalBasePath = "";
              fieldPath = fieldPath.substr(1);
            }
            if (!_.startsWith(fieldPath, "/")) {
              fieldPath = `/${slugValueBasePath && `${slugValueBasePath}.` || ""}${fieldPath}`;
            }
            if (_.startsWith(fieldPath, `/${originalBasePath}`))
              fieldPath = fieldPath.replace(`/${originalBasePath}`, `/${slugValueBasePath}`);
            return fieldPath;
          }
          const unwoundFields = slug.fields.map(unwindFieldPath);
          const unwoundGroupPaths = (slug.uniqueGroupFields || []).map(unwindFieldPath);
          if (_.some(
            unwoundFields.concat(unwoundGroupPaths),
            (path) => docIsModified(doc, path.replace(/^\//, ""))
          )) {
            const s = _.cloneDeep(slug);
            s.path = slugPath;
            s.basePath = unwoundBasePath;
            s.fields = unwoundFields;
            s.uniqueGroupFields = unwoundGroupPaths;
            unwoundSlugs.push(s);
          }
        });
      });
      return unwoundSlugs;
    }
    function unwindPath(doc, path, restPathParts) {
      if (restPathParts === void 0) {
        restPathParts = path.split(".$.");
        path = restPathParts[0];
        restPathParts = _.drop(restPathParts);
      }
      let res = [];
      const value = docGet(doc, path);
      if (_.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const childPath = `${path}.${i}.${restPathParts[0]}`;
          res = res.concat(unwindPath(doc, childPath, _.drop(restPathParts)));
        }
      } else if (!restPathParts || !restPathParts.length)
        res.push(path);
      return res;
    }
    async function setSlugs(doc, slugs, options, findOne, cache) {
      await Promise.all(
        slugs.map(async (slug) => {
          const fields = [];
          slug.fields.forEach((slugField) => {
            let fieldVal = docGet(doc, slugField.replace(/^\//, ""));
            if (slug.transform) {
              fieldVal = slug.transform(fieldVal);
            }
            fields.push(fieldVal);
          });
          const oldSlug = docGet(doc, slug.path);
          if (!(slug.unique || slug.uniqueSlug) && (!slug.uniqueGroupFields || !slug.uniqueGroupFields.length)) {
            if (!oldSlug || !slug.permanent) {
              docSet(doc, slug.path, makeSlug(fields, options));
            }
          } else {
            const query = {};
            if (slug.uniqueGroupFields) {
              slug.uniqueGroupFields.forEach((fieldName) => {
                fieldName = fieldName.replace(/^\//, "");
                query[fieldName] = docGet(doc, fieldName);
              });
            }
            if (!docGet(doc, slug.path) || !slug.permanent) {
              if (slug.isShortIdMode) {
                docSet(
                  doc,
                  slug.path,
                  await makeUniqueShortIdSlug(
                    doc,
                    slug.path,
                    fields,
                    options,
                    query,
                    findOne,
                    slug.forceShortId,
                    cache
                    // slugsMdfPaths
                  )
                );
              } else {
                docSet(
                  doc,
                  slug.path,
                  await makeUniqueCounterSlug(
                    doc,
                    slug.path,
                    fields,
                    options,
                    slug.padding,
                    query,
                    findOne,
                    cache,
                    slug.permanent
                    // slugsMdfPaths
                  )
                );
              }
            }
          }
        })
      );
      return doc;
    }
    function makeSlug(values, options) {
      const slug = getSlug(values.join(" "), options);
      return slug;
    }
    function extractCounter(value, separator) {
      let count = 0;
      const test = new RegExp(`${separator}(\\d+)$`);
      let match = null;
      if (match = value.match(test)) {
        count = match[1];
      }
      return parseInt(count);
    }
    async function makeUniqueCounterSlug(doc, path, values, options, padding, groups, findOne, cache, permanent) {
      let slug = makeSlug(values, options);
      const originalSlug = slug;
      let count = 0;
      const result = await findSame(
        cache,
        doc,
        groups,
        path,
        slug,
        true,
        options,
        findOne,
        permanent
        // slugsMdfPaths
      );
      if (result) {
        count = extractCounter(result, options.separator) + 1;
        slug += options.separator + _.padStart(count, padding, "0");
      }
      updateUpdCache(cache, path, originalSlug, slug, groups);
      return slug;
    }
    async function makeUniqueShortIdSlug(doc, path, values, options, groups, findOne, forceShortId, cache) {
      let slug = makeSlug(values, options);
      const originalSlug = slug;
      const result = await findSame(
        cache,
        doc,
        groups,
        path,
        slug,
        false,
        options,
        findOne
        // slugsMdfPaths
      );
      if (result) {
        const oldSlug = docGet(doc, path);
        if (
          // reuse old slug if possible
          oldSlug && oldSlug.match(new RegExp(`^${slug}${options.separator}.*$`))
        ) {
          slug = oldSlug;
        } else
          slug += options.separator + shortId.generate();
      } else if (forceShortId) {
        slug += options.separator + shortId.generate();
      }
      updateUpdCache(cache, path, originalSlug, slug, groups);
      return slug;
    }
  }
});

// node_modules/mongoose-slug-updater/index.js
var require_mongoose_slug_updater = __commonJS({
  "node_modules/mongoose-slug-updater/index.js"(exports, module) {
    module.exports = require_slug_generator();
  }
});
export default require_mongoose_slug_updater();
//# sourceMappingURL=mongoose-slug-updater.js.map
