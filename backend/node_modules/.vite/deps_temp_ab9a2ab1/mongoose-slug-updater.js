import {
  require_lodash
} from "./chunk-4H6IFO4E.js";
import {
  __commonJS
} from "./chunk-CQXHTUV2.js";

// node_modules/deepdash/private/getMixOrPatchIn.js
var require_getMixOrPatchIn = __commonJS({
  "node_modules/deepdash/private/getMixOrPatchIn.js"(exports, module) {
    "use strict";
    function getMixOrPatchIn(_) {
      function mixOrPatchIn(name, method, chain) {
        if (!_[name]) {
          if (_.mixin) {
            var patch = {};
            patch[name] = method;
            _.mixin(patch, { chain });
          } else {
            _[name] = method;
          }
        }
        return _;
      }
      return mixOrPatchIn;
    }
    module.exports = getMixOrPatchIn;
  }
});

// node_modules/deepdash/getCondense.js
var require_getCondense = __commonJS({
  "node_modules/deepdash/getCondense.js"(exports, module) {
    "use strict";
    function getCondense(_) {
      function condense(arr) {
        var indexes = [];
        for (var i = 0; i < arr.length; i++) {
          if (!(i in arr)) {
            indexes.push(i);
          }
        }
        var length = indexes.length;
        while (length--) {
          arr.splice(indexes[length], 1);
        }
        return arr;
      }
      return condense;
    }
    module.exports = getCondense;
  }
});

// node_modules/deepdash/addCondense.js
var require_addCondense = __commonJS({
  "node_modules/deepdash/addCondense.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getCondense = require_getCondense();
    function addCondense(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("condense", getCondense(), !getCondense.notChainable);
    }
    module.exports = addCondense;
  }
});

// node_modules/deepdash/getPathToString.js
var require_getPathToString = __commonJS({
  "node_modules/deepdash/getPathToString.js"(exports, module) {
    "use strict";
    var rxArrIndex = /\D/;
    var rxVarName = /^[a-zA-Z_$]+([\w_$]*)$/;
    var rxQuot = /"/g;
    function joinPaths() {
      var paths = [], len = arguments.length;
      while (len--)
        paths[len] = arguments[len];
      return paths.reduce(
        function(acc, p) {
          return acc ? !p || p.startsWith("[") ? "" + acc + p : acc + "." + p : p;
        },
        ""
      );
    }
    function getPathToString(_) {
      function pathToString(path) {
        var prefixes = [], len = arguments.length - 1;
        while (len-- > 0)
          prefixes[len] = arguments[len + 1];
        prefixes = prefixes.filter(function(p) {
          return p !== void 0;
        });
        if (_.isString(path)) {
          return joinPaths.apply(void 0, prefixes.concat([path]));
        }
        if (!Array.isArray(path)) {
          return void 0;
        }
        prefixes = joinPaths.apply(void 0, prefixes);
        return path.reduce(function(acc, value) {
          var type = typeof value;
          if (type === "number") {
            if (value < 0 || value % 1 !== 0) {
              return acc + '["' + value + '"]';
            } else {
              return acc + "[" + value + "]";
            }
          } else if (type !== "string") {
            return acc + '["' + value + '"]';
          } else if (!value) {
            return acc + '[""]';
          }
          if (!rxArrIndex.test(value)) {
            return acc + "[" + value + "]";
          }
          if (rxVarName.test(value)) {
            if (acc) {
              return acc + "." + value;
            } else {
              return "" + acc + value;
            }
          }
          return acc + '["' + value.replace(rxQuot, '\\"') + '"]';
        }, prefixes);
      }
      return pathToString;
    }
    getPathToString.notChainable = true;
    module.exports = getPathToString;
  }
});

// node_modules/deepdash/private/isObject.js
var require_isObject = __commonJS({
  "node_modules/deepdash/private/isObject.js"(exports, module) {
    "use strict";
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/deepdash/private/getIterate.js
var require_getIterate = __commonJS({
  "node_modules/deepdash/private/getIterate.js"(exports, module) {
    "use strict";
    var getPathToString = require_getPathToString();
    var isObject = require_isObject();
    var rxVarName = /^[a-zA-Z_$]+([\w_$]*)$/;
    var rxQuot = /"/g;
    var has = Object.prototype.hasOwnProperty;
    function getIterate(_) {
      var pathToString = getPathToString(_);
      function iterate(item) {
        var options = item.options;
        var obj = item.obj;
        var callback = item.callback;
        options.pathFormatArray = options.pathFormat == "array";
        item.depth = 0;
        var broken = false;
        var breakIt = function() {
          broken = true;
          return false;
        };
        while (item) {
          if (broken) {
            break;
          }
          if (!item.inited) {
            item.inited = true;
            item.info = describeValue(item.value, options.ownPropertiesOnly);
            if (options.checkCircular) {
              item.circularParentIndex = -1;
              item.circularParent = null;
              item.isCircular = false;
              if (item.info.isObject && !item.info.isEmpty) {
                var parent = item.parent;
                while (parent) {
                  if (parent.value === item.value) {
                    item.isCircular = true;
                    item.circularParent = parent;
                    item.circularParentIndex = item.depth - parent.depth - 1;
                    break;
                  }
                  parent = parent.parent;
                }
              }
            }
            item.children = [];
            if (options.childrenPath) {
              options.childrenPath.forEach(function(cp, i) {
                var children = _.get(item.value, cp);
                var info = describeValue(children, options.ownPropertiesOnly);
                if (!info.isEmpty) {
                  item.children.push([
                    cp,
                    options.strChildrenPath[i],
                    children,
                    info
                  ]);
                }
              });
            }
            item.isLeaf = item.isCircular || options.childrenPath !== void 0 && !item.children.length || !item.info.isObject || item.info.isEmpty;
            item.needCallback = (item.depth || options.includeRoot) && (!options.leavesOnly || item.isLeaf);
            if (item.needCallback) {
              var contextReader = new ContextReader(obj, options, breakIt);
              contextReader.setItem(item, false);
              try {
                item.res = callback(
                  item.value,
                  item.key,
                  item.parent && item.parent.value,
                  contextReader
                );
              } catch (err) {
                if (err.message) {
                  err.message += "\ncallback failed before deep iterate at:\n" + pathToString(item.path);
                }
                throw err;
              }
            }
            if (broken) {
              break;
            }
            if (item.res !== false) {
              if (!broken && !item.isCircular && item.info.isObject) {
                if (options.childrenPath !== void 0 && (item.depth || !options.rootIsChildren)) {
                  item.childrenItems = [];
                  if (item.children.length) {
                    item.children.forEach(function(ref) {
                      var cp = ref[0];
                      var scp = ref[1];
                      var children = ref[2];
                      var info = ref[3];
                      item.childrenItems = item.childrenItems.concat(info.isArray ? getElements(item, children, options, cp, scp) : getOwnChildren(item, children, options, cp, scp));
                    });
                  }
                } else {
                  item.childrenItems = item.info.isArray ? getElements(item, item.value, options, [], "") : getOwnChildren(item, item.value, options, [], "");
                }
              }
            }
            item.currentChildIndex = -1;
          }
          if (item.childrenItems && item.currentChildIndex < item.childrenItems.length - 1) {
            item.currentChildIndex++;
            item.childrenItems[item.currentChildIndex].parentItem = item;
            item = item.childrenItems[item.currentChildIndex];
            continue;
          }
          if (item.needCallback && options.callbackAfterIterate) {
            var contextReader$1 = new ContextReader(obj, options, breakIt);
            contextReader$1.setItem(item, true);
            try {
              callback(
                item.value,
                item.key,
                item.parent && item.parent.value,
                contextReader$1
              );
            } catch (err) {
              if (err.message) {
                err.message += "\ncallback failed after deep iterate at:\n" + pathToString(item.path);
              }
              throw err;
            }
          }
          item = item.parentItem;
        }
      }
      return iterate;
      function getElements(item, children, options, childrenPath, strChildrenPath) {
        var strChildPathPrefix;
        if (!options.pathFormatArray) {
          strChildPathPrefix = item.strPath || "";
          if (strChildrenPath && strChildPathPrefix && !strChildrenPath.startsWith("[")) {
            strChildPathPrefix += ".";
          }
          strChildPathPrefix += strChildrenPath || "";
        }
        var res = [];
        for (var i = 0; i < children.length; i++) {
          var val = children[i];
          if (val === void 0 && !(i in children)) {
            continue;
          }
          var strChildPath = void 0;
          var pathFormatString = !options.pathFormatArray;
          if (pathFormatString) {
            strChildPath = strChildPathPrefix + "[" + i + "]";
          }
          res.push({
            value: val,
            key: i + "",
            path: (item.path || []).concat(childrenPath, [i + ""]),
            strPath: strChildPath,
            depth: item.depth + 1,
            parent: {
              value: item.value,
              key: item.key,
              path: pathFormatString ? item.strPath : item.path,
              parent: item.parent,
              depth: item.depth,
              info: item.info
            },
            childrenPath: childrenPath.length && childrenPath || void 0,
            strChildrenPath: strChildrenPath || void 0
          });
        }
        return res;
      }
      function getOwnChildren(item, children, options, childrenPath, strChildrenPath) {
        var strChildPathPrefix;
        if (!options.pathFormatArray) {
          strChildPathPrefix = item.strPath || "";
          if (strChildrenPath && strChildPathPrefix && !strChildrenPath.startsWith("[")) {
            strChildPathPrefix += ".";
          }
          strChildPathPrefix += strChildrenPath || "";
        }
        var res = [];
        var pathFormatString = !options.pathFormatArray;
        for (var childKey in children) {
          if (options.ownPropertiesOnly && !has.call(children, childKey)) {
            continue;
          }
          var strChildPath = void 0;
          if (pathFormatString) {
            if (rxVarName.test(childKey)) {
              if (strChildPathPrefix) {
                strChildPath = strChildPathPrefix + "." + childKey;
              } else {
                strChildPath = "" + childKey;
              }
            } else {
              strChildPath = strChildPathPrefix + '["' + childKey.replace(
                rxQuot,
                '\\"'
              ) + '"]';
            }
          }
          res.push({
            value: children[childKey],
            key: childKey,
            path: (item.path || []).concat(childrenPath, [childKey]),
            strPath: strChildPath,
            depth: item.depth + 1,
            parent: {
              value: item.value,
              key: item.key,
              path: pathFormatString ? item.strPath : item.path,
              parent: item.parent,
              depth: item.depth,
              info: item.info
            },
            childrenPath: childrenPath.length && childrenPath || void 0,
            strChildrenPath: strChildrenPath || void 0
          });
        }
        return res;
      }
    }
    var ContextReader = function ContextReader2(obj, options, breakIt) {
      this.obj = obj;
      this._options = options;
      this["break"] = breakIt;
    };
    var prototypeAccessors = { path: { configurable: true }, parent: { configurable: true }, parents: { configurable: true }, depth: { configurable: true }, isLeaf: { configurable: true }, isCircular: { configurable: true }, circularParentIndex: { configurable: true }, circularParent: { configurable: true }, childrenPath: { configurable: true }, info: { configurable: true } };
    ContextReader.prototype.setItem = function setItem(item, afterIterate) {
      this._item = item;
      this.afterIterate = afterIterate;
    };
    prototypeAccessors.path.get = function() {
      return this._options.pathFormatArray ? this._item.path : this._item.strPath;
    };
    prototypeAccessors.parent.get = function() {
      return this._item.parent;
    };
    prototypeAccessors.parents.get = function() {
      if (!this._item._parents) {
        this._item._parents = [];
        var curParent = this._item.parent;
        while (curParent) {
          this._item._parents[curParent.depth] = curParent;
          curParent = curParent.parent;
        }
      }
      return this._item._parents;
    };
    prototypeAccessors.depth.get = function() {
      return this._item.depth;
    };
    prototypeAccessors.isLeaf.get = function() {
      return this._item.isLeaf;
    };
    prototypeAccessors.isCircular.get = function() {
      return this._item.isCircular;
    };
    prototypeAccessors.circularParentIndex.get = function() {
      return this._item.circularParentIndex;
    };
    prototypeAccessors.circularParent.get = function() {
      return this._item.circularParent;
    };
    prototypeAccessors.childrenPath.get = function() {
      return this._options.childrenPath !== void 0 && (this._options.pathFormatArray ? this._item.childrenPath : this._item.strChildrenPath) || void 0;
    };
    prototypeAccessors.info.get = function() {
      return this._item.info;
    };
    Object.defineProperties(ContextReader.prototype, prototypeAccessors);
    function isObjectEmpty(value, ownPropertiesOnly) {
      for (var key in value) {
        if (!ownPropertiesOnly || has.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    function describeValue(value, ownPropertiesOnly) {
      var res = { isObject: isObject(value) };
      res.isArray = res.isObject && Array.isArray(value);
      res.isEmpty = res.isArray ? !value.length : res.isObject ? isObjectEmpty(value, ownPropertiesOnly) : true;
      return res;
    }
    module.exports = getIterate;
  }
});

// node_modules/deepdash/getEachDeep.js
var require_getEachDeep = __commonJS({
  "node_modules/deepdash/getEachDeep.js"(exports, module) {
    "use strict";
    var getIterate = require_getIterate();
    function getEachDeep(_) {
      var iterate = getIterate(_);
      function eachDeep(obj, callback, options) {
        if (callback === void 0) {
          callback = _.identity;
        }
        options = _.merge(
          {
            includeRoot: !Array.isArray(obj),
            pathFormat: "string",
            checkCircular: false,
            leavesOnly: false,
            ownPropertiesOnly: true
            //
          },
          options || {}
        );
        if (options.childrenPath !== void 0) {
          if (!options.includeRoot && options.rootIsChildren === void 0) {
            options.rootIsChildren = Array.isArray(obj);
          }
          if (!_.isString(options.childrenPath) && !Array.isArray(options.childrenPath)) {
            throw Error("childrenPath can be string or array");
          } else {
            if (_.isString(options.childrenPath)) {
              options.childrenPath = [options.childrenPath];
            }
            options.strChildrenPath = options.childrenPath;
            options.childrenPath = [];
            for (var i = options.strChildrenPath.length - 1; i >= 0; i--) {
              options.childrenPath[i] = _.toPath(options.strChildrenPath[i]);
            }
          }
        }
        iterate({
          value: obj,
          callback,
          options,
          obj
        });
        return obj;
      }
      return eachDeep;
    }
    module.exports = getEachDeep;
  }
});

// node_modules/deepdash/getCondenseDeep.js
var require_getCondenseDeep = __commonJS({
  "node_modules/deepdash/getCondenseDeep.js"(exports, module) {
    "use strict";
    var getCondense = require_getCondense();
    var getEachDeep = require_getEachDeep();
    function getCondenseDeep(_) {
      var eachDeep = getEachDeep(_);
      var condense = getCondense();
      var _each = _.each || _.forArray;
      function condenseDeep(obj, options) {
        options = _.merge(
          {
            checkCircular: false
          },
          options || {}
        );
        var eachDeepOptions = {
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly
        };
        var arrays = [];
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.isCircular && Array.isArray(value)) {
              arrays.push(value);
            }
          },
          eachDeepOptions
        );
        if (Array.isArray(obj)) {
          arrays.push(obj);
        }
        _each(arrays, condense);
        return obj;
      }
      return condenseDeep;
    }
    module.exports = getCondenseDeep;
  }
});

// node_modules/deepdash/addCondenseDeep.js
var require_addCondenseDeep = __commonJS({
  "node_modules/deepdash/addCondenseDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getCondenseDeep = require_getCondenseDeep();
    function addCondenseDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("condenseDeep", getCondenseDeep(_), !getCondenseDeep.notChainable);
    }
    module.exports = addCondenseDeep;
  }
});

// node_modules/deepdash/addEachDeep.js
var require_addEachDeep = __commonJS({
  "node_modules/deepdash/addEachDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getEachDeep = require_getEachDeep();
    function addEachDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("eachDeep", getEachDeep(_), !getEachDeep.notChainable);
    }
    module.exports = addEachDeep;
  }
});

// node_modules/deepdash/getExists.js
var require_getExists = __commonJS({
  "node_modules/deepdash/getExists.js"(exports, module) {
    "use strict";
    function getExists(_) {
      function exists(obj, path) {
        path = Array.isArray(path) ? _.clone(path) : _.toPath(path);
        var key = path.pop();
        var parent = path.length ? _.get(obj, path) : obj;
        return parent !== void 0 && key in parent;
      }
      return exists;
    }
    getExists.notChainable = true;
    module.exports = getExists;
  }
});

// node_modules/deepdash/addExists.js
var require_addExists = __commonJS({
  "node_modules/deepdash/addExists.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getExists = require_getExists();
    function addExists(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("exists", getExists(_), !getExists.notChainable);
    }
    module.exports = addExists;
  }
});

// node_modules/deepdash/getFilterDeep.js
var require_getFilterDeep = __commonJS({
  "node_modules/deepdash/getFilterDeep.js"(exports, module) {
    "use strict";
    var getCondense = require_getCondense();
    var isObject = require_isObject();
    var getEachDeep = require_getEachDeep();
    function getFilterDeep(_) {
      var eachDeep = getEachDeep(_);
      var condense = getCondense();
      function filterDeep(obj, predicate, options) {
        predicate = _.iteratee(predicate);
        if (!options) {
          options = {};
        } else {
          options = _.cloneDeep(options);
          if (options.leafsOnly !== void 0) {
            options.leavesOnly = options.leafsOnly;
          }
        }
        if (!options.onTrue) {
          options.onTrue = {};
        }
        if (!options.onFalse) {
          options.onFalse = {};
        }
        if (!options.onUndefined) {
          options.onUndefined = {};
        }
        if (options.childrenPath !== void 0) {
          if (options.onTrue.skipChildren === void 0) {
            options.onTrue.skipChildren = false;
          }
          if (options.onUndefined.skipChildren === void 0) {
            options.onUndefined.skipChildren = false;
          }
          if (options.onFalse.skipChildren === void 0) {
            options.onFalse.skipChildren = false;
          }
          if (options.onTrue.cloneDeep === void 0) {
            options.onTrue.cloneDeep = true;
          }
          if (options.onUndefined.cloneDeep === void 0) {
            options.onUndefined.cloneDeep = true;
          }
          if (options.onFalse.cloneDeep === void 0) {
            options.onFalse.cloneDeep = true;
          }
        }
        options = _.merge(
          {
            checkCircular: false,
            keepCircular: true,
            //replaceCircularBy: <by>,
            leavesOnly: options.childrenPath === void 0,
            condense: true,
            cloneDeep: _.cloneDeep,
            pathFormat: "string",
            onTrue: { skipChildren: true, cloneDeep: true, keepIfEmpty: true },
            onUndefined: {
              skipChildren: false,
              cloneDeep: false,
              keepIfEmpty: false
            },
            onFalse: {
              skipChildren: true,
              cloneDeep: false,
              keepIfEmpty: false
            }
          },
          options
        );
        var eachDeepOptions = {
          pathFormat: options.pathFormat,
          checkCircular: options.checkCircular,
          childrenPath: options.childrenPath,
          includeRoot: options.includeRoot,
          rootIsChildren: options.rootIsChildren,
          ownPropertiesOnly: options.ownPropertiesOnly,
          callbackAfterIterate: true,
          leavesOnly: false
        };
        var resIsArray = Array.isArray(obj);
        var res = resIsArray ? [] : isObject(obj) ? {} : null;
        var toCondense = options.condense ? [] : false;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.afterIterate) {
              context.info._filterDeep = {};
              if (!context.isCircular) {
                var reply = !options.leavesOnly || context.isLeaf ? predicate(value, key, parent, context) : void 0;
                if (!isObject(reply)) {
                  if (reply === void 0) {
                    reply = options.onUndefined;
                  } else if (reply) {
                    reply = options.onTrue;
                  } else {
                    reply = options.onFalse;
                  }
                }
                context.info._filterDeep.reply = reply;
                context.info._filterDeep.empty = reply.empty === void 0 ? true : reply.empty;
                if (reply.keepIfEmpty || !reply.skipChildren) {
                  if (options.cloneDeep && reply.cloneDeep) {
                    if (context.path !== void 0) {
                      var children = takeResultParent(context, res);
                      context.info._filterDeep.res = children[key] = options.cloneDeep(value);
                    } else {
                      context.info._filterDeep.res = res = options.cloneDeep(value);
                    }
                  } else {
                    if (context.path !== void 0) {
                      var children$1 = takeResultParent(context, res);
                      context.info._filterDeep.res = children$1[key] = context.info.isArray ? [] : context.info.isObject ? {} : value;
                    } else {
                      context.info._filterDeep.res = res = context.info.isArray ? [] : context.info.isObject ? {} : value;
                    }
                  }
                }
                return !reply.skipChildren;
              } else {
                var children$2 = takeResultParent(context, res);
                if (!options.keepCircular) {
                  delete children$2[key];
                  if (toCondense && (children$2 === context.parent.info._filterDeep.res && context.parent.info.isArray || Array.isArray(children$2)) && !context.parent.info._filterDeep.isSparse) {
                    context.parent.info._filterDeep.isSparse = true;
                    toCondense.push(context.parent.info);
                  }
                  context.info._filterDeep.excluded = true;
                } else {
                  context.info._filterDeep.res = children$2[key] = "replaceCircularBy" in options ? options.replaceCircularBy : context.circularParent.path !== void 0 ? context.circularParent.info._filterDeep.res : res;
                }
                return false;
              }
            } else if (context.afterIterate && !context.isCircular) {
              var reply$1 = context.info._filterDeep.reply;
              if (context.info._filterDeep.empty && !reply$1.keepIfEmpty) {
                if (context.path === void 0) {
                  res = null;
                } else {
                  var children$3 = takeResultParent(context, res);
                  delete children$3[key];
                  if (toCondense && (children$3 === context.parent.info._filterDeep.res && context.parent.info.isArray || Array.isArray(children$3)) && !context.parent.info._filterDeep.isSparse) {
                    context.parent.info._filterDeep.isSparse = true;
                    toCondense.push(context.parent.info);
                  }
                  context.info._filterDeep.excluded = true;
                }
              } else {
                var parent$1 = context.parent;
                while (parent$1) {
                  if (!parent$1.info._filterDeep.reply) {
                    parent$1.info._filterDeep.reply = options.onUndefined;
                  }
                  if (!parent$1.info._filterDeep.empty) {
                    break;
                  }
                  parent$1.info._filterDeep.empty = false;
                  parent$1 = parent$1.parent;
                }
              }
              return;
            }
          },
          eachDeepOptions
        );
        if (toCondense) {
          for (var i = 0; i < toCondense.length; i++) {
            var info = toCondense[i];
            if (info._filterDeep.isSparse && !info._filterDeep.excluded) {
              condense(info.children);
            }
          }
          if (resIsArray) {
            condense(res);
          }
        }
        if (resIsArray && !res.length && !eachDeepOptions.includeRoot) {
          return null;
        }
        return res;
      }
      return filterDeep;
      function takeResultParent(context, res) {
        if (context.parent.info.children) {
          return context.parent.info.children;
        }
        if (!context.parent.info._filterDeep) {
          context.parent.info._filterDeep = {};
        }
        var parent = context.parent.info._filterDeep.res;
        if (parent === void 0) {
          parent = context.parent.info._filterDeep.res = res;
        }
        if (context._item.childrenPath) {
          var oParent = context.parent.value;
          for (var i = 0; i < context._item.childrenPath.length; i++) {
            var childKey = context._item.childrenPath[i];
            oParent = oParent[childKey];
            if (!parent[childKey]) {
              parent[childKey] = Array.isArray(oParent) ? [] : {};
            }
            parent = parent[childKey];
          }
        }
        context.parent.info.children = parent;
        return parent;
      }
    }
    module.exports = getFilterDeep;
  }
});

// node_modules/deepdash/addFilterDeep.js
var require_addFilterDeep = __commonJS({
  "node_modules/deepdash/addFilterDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFilterDeep = require_getFilterDeep();
    function addFilterDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("filterDeep", getFilterDeep(_), !getFilterDeep.notChainable);
    }
    module.exports = addFilterDeep;
  }
});

// node_modules/deepdash/getFindDeep.js
var require_getFindDeep = __commonJS({
  "node_modules/deepdash/getFindDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getFindDeep(_) {
      var eachDeep = getEachDeep(_);
      function findDeep(obj, predicate, options) {
        predicate = _.iteratee(predicate);
        if (!options) {
          options = {};
        } else {
          options = _.cloneDeep(options);
          if (options.leafsOnly !== void 0) {
            options.leavesOnly = options.leafsOnly;
          }
        }
        options = _.merge(
          {
            checkCircular: false,
            leavesOnly: options.childrenPath === void 0,
            pathFormat: "string"
          },
          options
        );
        var eachDeepOptions = {
          pathFormat: options.pathFormat,
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly,
          childrenPath: options.childrenPath,
          includeRoot: options.includeRoot,
          rootIsChildren: options.rootIsChildren,
          callbackAfterIterate: false,
          leavesOnly: options.leavesOnly
        };
        var res;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (predicate(value, key, parent, context)) {
              res = { value, key, parent, context };
              return context["break"]();
            }
          },
          eachDeepOptions
        );
        return res;
      }
      return findDeep;
    }
    module.exports = getFindDeep;
  }
});

// node_modules/deepdash/addFindDeep.js
var require_addFindDeep = __commonJS({
  "node_modules/deepdash/addFindDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFindDeep = require_getFindDeep();
    function addFindDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("findDeep", getFindDeep(_), !getFindDeep.notChainable);
    }
    module.exports = addFindDeep;
  }
});

// node_modules/deepdash/getFindPathDeep.js
var require_getFindPathDeep = __commonJS({
  "node_modules/deepdash/getFindPathDeep.js"(exports, module) {
    "use strict";
    var getFindDeep = require_getFindDeep();
    function getFindPathDeep(_) {
      var findDeep = getFindDeep(_);
      function findPathDeep(obj, predicate, options) {
        var res = findDeep(obj, predicate, options);
        return res && res.context.path;
      }
      return findPathDeep;
    }
    module.exports = getFindPathDeep;
  }
});

// node_modules/deepdash/addFindPathDeep.js
var require_addFindPathDeep = __commonJS({
  "node_modules/deepdash/addFindPathDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFindPathDeep = require_getFindPathDeep();
    function addFindPathDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("findPathDeep", getFindPathDeep(_), !getFindPathDeep.notChainable);
    }
    module.exports = addFindPathDeep;
  }
});

// node_modules/deepdash/getFindValueDeep.js
var require_getFindValueDeep = __commonJS({
  "node_modules/deepdash/getFindValueDeep.js"(exports, module) {
    "use strict";
    var getFindDeep = require_getFindDeep();
    function getFindValueDeep(_) {
      var findDeep = getFindDeep(_);
      function findValueDeep(obj, predicate, options) {
        var res = findDeep(obj, predicate, options);
        return res && res.value;
      }
      return findValueDeep;
    }
    module.exports = getFindValueDeep;
  }
});

// node_modules/deepdash/addFindValueDeep.js
var require_addFindValueDeep = __commonJS({
  "node_modules/deepdash/addFindValueDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getFindValueDeep = require_getFindValueDeep();
    function addFindValueDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("findValueDeep", getFindValueDeep(_), !getFindValueDeep.notChainable);
    }
    module.exports = addFindValueDeep;
  }
});

// node_modules/deepdash/getForEachDeep.js
var require_getForEachDeep = __commonJS({
  "node_modules/deepdash/getForEachDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getForEachDeep(_) {
      return getEachDeep(_);
    }
    module.exports = getForEachDeep;
  }
});

// node_modules/deepdash/addForEachDeep.js
var require_addForEachDeep = __commonJS({
  "node_modules/deepdash/addForEachDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getForEachDeep = require_getForEachDeep();
    function addForEachDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("forEachDeep", getForEachDeep(_), !getForEachDeep.notChainable);
    }
    module.exports = addForEachDeep;
  }
});

// node_modules/deepdash/getIndex.js
var require_getIndex = __commonJS({
  "node_modules/deepdash/getIndex.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getIndex(_) {
      var eachDeep = getEachDeep(_);
      function index(obj, options) {
        options = _.merge(
          {
            checkCircular: false,
            includeCircularPath: true,
            leavesOnly: !options || options.childrenPath === void 0
          },
          options || {}
        );
        if (options && options.leafsOnly !== void 0) {
          options.leavesOnly = options.leafsOnly;
        }
        var eachDeepOptions = {
          pathFormat: "string",
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly,
          includeRoot: options.includeRoot,
          childrenPath: options.childrenPath,
          rootIsChildren: options.rootIsChildren,
          leavesOnly: options.leavesOnly
        };
        var res = {};
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.isCircular || options.includeCircularPath) {
              if (context.path !== void 0) {
                res[context.path] = value;
              }
            }
          },
          eachDeepOptions
        );
        return res;
      }
      return index;
    }
    module.exports = getIndex;
  }
});

// node_modules/deepdash/addIndex.js
var require_addIndex = __commonJS({
  "node_modules/deepdash/addIndex.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getIndex = require_getIndex();
    function addIndex(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("index", getIndex(_), !getIndex.notChainable);
    }
    module.exports = addIndex;
  }
});

// node_modules/deepdash/getPaths.js
var require_getPaths = __commonJS({
  "node_modules/deepdash/getPaths.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getPaths(_) {
      var eachDeep = getEachDeep(_);
      function paths(obj, options) {
        if (options && options.leafsOnly !== void 0) {
          options.leavesOnly = options.leafsOnly;
        }
        options = _.merge(
          {
            checkCircular: false,
            includeCircularPath: true,
            leavesOnly: !options || options.childrenPath === void 0,
            pathFormat: "string"
          },
          options || {}
        );
        var eachDeepOptions = {
          pathFormat: options.pathFormat,
          checkCircular: options.checkCircular,
          ownPropertiesOnly: options.ownPropertiesOnly,
          includeRoot: options.includeRoot,
          childrenPath: options.childrenPath,
          rootIsChildren: options.rootIsChildren,
          leavesOnly: options.leavesOnly
        };
        var res = [];
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!context.isCircular || options.includeCircularPath) {
              if (context.path !== void 0) {
                res.push(context.path);
              }
            }
          },
          eachDeepOptions
        );
        return res;
      }
      return paths;
    }
    module.exports = getPaths;
  }
});

// node_modules/deepdash/getKeysDeep.js
var require_getKeysDeep = __commonJS({
  "node_modules/deepdash/getKeysDeep.js"(exports, module) {
    "use strict";
    var getPaths = require_getPaths();
    function getKeysDeep(_) {
      return getPaths(_);
    }
    module.exports = getKeysDeep;
  }
});

// node_modules/deepdash/addKeysDeep.js
var require_addKeysDeep = __commonJS({
  "node_modules/deepdash/addKeysDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getKeysDeep = require_getKeysDeep();
    function addKeysDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("keysDeep", getKeysDeep(_), !getKeysDeep.notChainable);
    }
    module.exports = addKeysDeep;
  }
});

// node_modules/deepdash/getReduceDeep.js
var require_getReduceDeep = __commonJS({
  "node_modules/deepdash/getReduceDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getReduceDeep(_) {
      var eachDeep = getEachDeep(_);
      function reduceDeep(obj, iteratee, accumulator, options) {
        var accumulatorInited = accumulator !== void 0;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (!accumulatorInited) {
              accumulator = value;
              accumulatorInited = true;
            } else {
              accumulator = iteratee(accumulator, value, key, parent, context);
            }
          },
          options
        );
        return accumulator;
      }
      return reduceDeep;
    }
    module.exports = getReduceDeep;
  }
});

// node_modules/deepdash/getMapDeep.js
var require_getMapDeep = __commonJS({
  "node_modules/deepdash/getMapDeep.js"(exports, module) {
    "use strict";
    var getReduceDeep = require_getReduceDeep();
    function getMapDeep(_) {
      var reduceDeep = getReduceDeep(_);
      function mapDeep(obj, iteratee, options) {
        iteratee = _.iteratee(iteratee);
        return reduceDeep(
          obj,
          function(acc, value, key, parentValue, context) {
            acc.push(iteratee(value, key, parentValue, context));
            return acc;
          },
          [],
          options
        );
      }
      return mapDeep;
    }
    module.exports = getMapDeep;
  }
});

// node_modules/deepdash/addMapDeep.js
var require_addMapDeep = __commonJS({
  "node_modules/deepdash/addMapDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getMapDeep = require_getMapDeep();
    function addMapDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("mapDeep", getMapDeep(_), !getMapDeep.notChainable);
    }
    module.exports = addMapDeep;
  }
});

// node_modules/deepdash/getMapKeysDeep.js
var require_getMapKeysDeep = __commonJS({
  "node_modules/deepdash/getMapKeysDeep.js"(exports, module) {
    "use strict";
    var getPathToString = require_getPathToString();
    var getEachDeep = require_getEachDeep();
    function getMapKeysDeep(_) {
      var eachDeep = getEachDeep(_);
      var pathToString = getPathToString(_);
      function mapKeysDeep(obj, iteratee, options) {
        if (options === void 0)
          options = {};
        iteratee = _.iteratee(iteratee);
        options.cloneDeep = options.cloneDeep || _.cloneDeep;
        options.callbackAfterIterate = false;
        var newPaths = [];
        eachDeep(
          obj,
          function(value, key, parent, context) {
            if (key === void 0) {
              return;
            }
            var newKey = iteratee(value, key, parent, context) + "";
            if (newKey === key) {
              return;
            }
            var oldPath = context.path;
            var oldPathStr = options.pathFormat === "array" ? JSON.stringify(oldPath) : oldPath;
            var newPath = options.pathFormat === "array" ? (context.parent.path || []).concat(
              context.childrenPath || [],
              [newKey]
            ) : pathToString([newKey], context.parent.path, context.childrenPath);
            var newPathStr = options.pathFormat === "array" ? JSON.stringify(newPath) : newPath;
            if (!newPaths[context.depth - 1]) {
              newPaths[context.depth - 1] = [];
            }
            newPaths[context.depth - 1].push({
              oldPath,
              oldPathStr,
              newPath,
              newPathStr
            });
          },
          options
        );
        var res = options.cloneDeep(obj);
        var d = newPaths.length;
        var loop = function() {
          if (!newPaths[d]) {
            return;
          }
          var overwritten = {};
          newPaths[d].forEach(function(ref) {
            var oldPath = ref.oldPath;
            var oldPathStr = ref.oldPathStr;
            var newPath = ref.newPath;
            var newPathStr = ref.newPathStr;
            var value;
            if (Object.prototype.hasOwnProperty.call(overwritten, oldPathStr)) {
              value = overwritten[oldPathStr];
              delete overwritten[oldPathStr];
            } else {
              value = _.get(res, oldPath);
              if (value === void 0 && !_.has(res, oldPath)) {
                return;
              }
              _.unset(res, oldPath);
            }
            if (_.has(res, newPath) && !Object.prototype.hasOwnProperty.call(overwritten, newPathStr)) {
              overwritten[newPathStr] = _.get(res, newPath);
            }
            _.set(res, newPath, value);
          });
        };
        while (d--)
          loop();
        return res;
      }
      return mapKeysDeep;
    }
    module.exports = getMapKeysDeep;
  }
});

// node_modules/deepdash/addMapKeysDeep.js
var require_addMapKeysDeep = __commonJS({
  "node_modules/deepdash/addMapKeysDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getMapKeysDeep = require_getMapKeysDeep();
    function addMapKeysDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("mapKeysDeep", getMapKeysDeep(_), !getMapKeysDeep.notChainable);
    }
    module.exports = addMapKeysDeep;
  }
});

// node_modules/deepdash/getMapValuesDeep.js
var require_getMapValuesDeep = __commonJS({
  "node_modules/deepdash/getMapValuesDeep.js"(exports, module) {
    "use strict";
    var getEachDeep = require_getEachDeep();
    function getMapValuesDeep(_) {
      var eachDeep = getEachDeep(_);
      function mapValuesDeep(obj, iteratee, options) {
        iteratee = _.iteratee(iteratee);
        var res = Array.isArray(obj) ? [] : _.isObject(obj) ? {} : _.clone(obj);
        var skipChildren;
        eachDeep(
          obj,
          function(value, key, parent, context) {
            context.skipChildren = function(skip) {
              skipChildren = skip;
            };
            skipChildren = void 0;
            var r = iteratee(value, key, parent, context);
            if (!context.isLeaf && skipChildren === void 0) {
              skipChildren = value !== r && Array.isArray(value) != Array.isArray(r);
            }
            if (context.path !== void 0) {
              _.set(res, context.path, r);
            } else {
              res = r;
            }
            if (skipChildren) {
              return false;
            }
          },
          options
        );
        return res;
      }
      return mapValuesDeep;
    }
    module.exports = getMapValuesDeep;
  }
});

// node_modules/deepdash/addMapValuesDeep.js
var require_addMapValuesDeep = __commonJS({
  "node_modules/deepdash/addMapValuesDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getMapValuesDeep = require_getMapValuesDeep();
    function addMapValuesDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("mapValuesDeep", getMapValuesDeep(_), !getMapValuesDeep.notChainable);
    }
    module.exports = addMapValuesDeep;
  }
});

// node_modules/deepdash/getPathMatches.js
var require_getPathMatches = __commonJS({
  "node_modules/deepdash/getPathMatches.js"(exports, module) {
    "use strict";
    var getPathToString = require_getPathToString();
    function getPathMatches(_) {
      var pathToString = getPathToString(_);
      function pathMatches(path, paths) {
        var pathString;
        var pathArray;
        if (_.isString(path)) {
          pathString = path;
        } else {
          pathArray = path;
        }
        if (!Array.isArray(paths)) {
          paths = [paths];
        } else {
          paths = _.cloneDeep(paths);
        }
        for (var i = 0; i < paths.length; i++) {
          if (_.isString(paths[i])) {
            paths[i] = _.toPath(paths[i]);
          }
          if (Array.isArray(paths[i])) {
            if (pathArray === void 0) {
              pathArray = _.toPath(pathString);
            }
            if (pathArray.length >= paths[i].length && _.isEqual(_.takeRight(pathArray, paths[i].length), paths[i])) {
              return paths[i];
            }
          } else if (paths[i] instanceof RegExp) {
            if (pathString === void 0) {
              pathString = pathToString(path);
            }
            if (paths[i].test(pathString)) {
              return paths[i];
            }
          } else {
            throw new Error(
              "To match path use only string/regex or array of them."
            );
          }
        }
        return false;
      }
      return pathMatches;
    }
    getPathMatches.notChainable = true;
    module.exports = getPathMatches;
  }
});

// node_modules/deepdash/getOmitDeep.js
var require_getOmitDeep = __commonJS({
  "node_modules/deepdash/getOmitDeep.js"(exports, module) {
    "use strict";
    var getFilterDeep = require_getFilterDeep();
    var getPathMatches = require_getPathMatches();
    function getOmitDeep(_) {
      var pathMatches = getPathMatches(_);
      var filterDeep = getFilterDeep(_);
      function omitDeep(obj, paths, options) {
        options = _.merge(
          {
            invert: false
          },
          options || {}
        );
        var isOmit = !options.invert;
        options = _.merge(
          {
            onMatch: {
              cloneDeep: false,
              skipChildren: false,
              keepIfEmpty: !isOmit
            },
            onNotMatch: {
              cloneDeep: false,
              skipChildren: false,
              keepIfEmpty: isOmit
            }
          },
          options
        );
        options.leavesOnly = false;
        options.childrenPath = void 0;
        options.includeRoot = void 0;
        options.pathFormat = "array";
        options.onTrue = options.invert ? options.onMatch : options.onNotMatch;
        options.onFalse = options.invert ? options.onNotMatch : options.onMatch;
        var test = function(value, key, parent, context) {
          if (pathMatches(context.path, paths) !== false) {
            return options.invert;
          } else {
            return !options.invert;
          }
        };
        return filterDeep(obj, test, options);
      }
      return omitDeep;
    }
    module.exports = getOmitDeep;
  }
});

// node_modules/deepdash/addOmitDeep.js
var require_addOmitDeep = __commonJS({
  "node_modules/deepdash/addOmitDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getOmitDeep = require_getOmitDeep();
    function addOmitDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("omitDeep", getOmitDeep(_), !getOmitDeep.notChainable);
    }
    module.exports = addOmitDeep;
  }
});

// node_modules/deepdash/addPathMatches.js
var require_addPathMatches = __commonJS({
  "node_modules/deepdash/addPathMatches.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPathMatches = require_getPathMatches();
    function addPathMatches(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("pathMatches", getPathMatches(_), !getPathMatches.notChainable);
    }
    module.exports = addPathMatches;
  }
});

// node_modules/deepdash/addPathToString.js
var require_addPathToString = __commonJS({
  "node_modules/deepdash/addPathToString.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPathToString = require_getPathToString();
    function addPathToString(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("pathToString", getPathToString(_), !getPathToString.notChainable);
    }
    module.exports = addPathToString;
  }
});

// node_modules/deepdash/addPaths.js
var require_addPaths = __commonJS({
  "node_modules/deepdash/addPaths.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPaths = require_getPaths();
    function addPaths(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("paths", getPaths(_), !getPaths.notChainable);
    }
    module.exports = addPaths;
  }
});

// node_modules/deepdash/getPickDeep.js
var require_getPickDeep = __commonJS({
  "node_modules/deepdash/getPickDeep.js"(exports, module) {
    "use strict";
    var getOmitDeep = require_getOmitDeep();
    function getPickDeep(_) {
      var omitDeep = getOmitDeep(_);
      function pickDeep(obj, paths, options) {
        options = _.merge(
          {
            invert: false
          },
          options || {}
        );
        options.invert = true;
        return omitDeep(obj, paths, options);
      }
      return pickDeep;
    }
    module.exports = getPickDeep;
  }
});

// node_modules/deepdash/addPickDeep.js
var require_addPickDeep = __commonJS({
  "node_modules/deepdash/addPickDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getPickDeep = require_getPickDeep();
    function addPickDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("pickDeep", getPickDeep(_), !getPickDeep.notChainable);
    }
    module.exports = addPickDeep;
  }
});

// node_modules/deepdash/addReduceDeep.js
var require_addReduceDeep = __commonJS({
  "node_modules/deepdash/addReduceDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getReduceDeep = require_getReduceDeep();
    function addReduceDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("reduceDeep", getReduceDeep(_), !getReduceDeep.notChainable);
    }
    module.exports = addReduceDeep;
  }
});

// node_modules/deepdash/getSomeDeep.js
var require_getSomeDeep = __commonJS({
  "node_modules/deepdash/getSomeDeep.js"(exports, module) {
    "use strict";
    var getFindDeep = require_getFindDeep();
    function getSomeDeep(_) {
      var findDeep = getFindDeep(_);
      function someDeep(obj, predicate, options) {
        return !!findDeep(obj, predicate, options);
      }
      return someDeep;
    }
    module.exports = getSomeDeep;
  }
});

// node_modules/deepdash/addSomeDeep.js
var require_addSomeDeep = __commonJS({
  "node_modules/deepdash/addSomeDeep.js"(exports, module) {
    "use strict";
    var getMixOrPatchIn = require_getMixOrPatchIn();
    var getSomeDeep = require_getSomeDeep();
    function addSomeDeep(_) {
      var mixOrPatchIn = getMixOrPatchIn(_);
      return mixOrPatchIn("someDeep", getSomeDeep(_), !getSomeDeep.notChainable);
    }
    module.exports = addSomeDeep;
  }
});

// node_modules/deepdash/deepdash.js
var require_deepdash = __commonJS({
  "node_modules/deepdash/deepdash.js"(exports, module) {
    "use strict";
    var addCondense = require_addCondense();
    var addCondenseDeep = require_addCondenseDeep();
    var addEachDeep = require_addEachDeep();
    var addExists = require_addExists();
    var addFilterDeep = require_addFilterDeep();
    var addFindDeep = require_addFindDeep();
    var addFindPathDeep = require_addFindPathDeep();
    var addFindValueDeep = require_addFindValueDeep();
    var addForEachDeep = require_addForEachDeep();
    var addIndex = require_addIndex();
    var addKeysDeep = require_addKeysDeep();
    var addMapDeep = require_addMapDeep();
    var addMapKeysDeep = require_addMapKeysDeep();
    var addMapValuesDeep = require_addMapValuesDeep();
    var addOmitDeep = require_addOmitDeep();
    var addPathMatches = require_addPathMatches();
    var addPathToString = require_addPathToString();
    var addPaths = require_addPaths();
    var addPickDeep = require_addPickDeep();
    var addReduceDeep = require_addReduceDeep();
    var addSomeDeep = require_addSomeDeep();
    function apply(_) {
      addCondense(_);
      addCondenseDeep(_);
      addEachDeep(_);
      addExists(_);
      addFilterDeep(_);
      addFindDeep(_);
      addFindPathDeep(_);
      addFindValueDeep(_);
      addForEachDeep(_);
      addIndex(_);
      addKeysDeep(_);
      addMapDeep(_);
      addMapKeysDeep(_);
      addMapValuesDeep(_);
      addOmitDeep(_);
      addPathMatches(_);
      addPathToString(_);
      addPaths(_);
      addPickDeep(_);
      addReduceDeep(_);
      addSomeDeep(_);
      return _;
    }
    module.exports = apply;
  }
});

// node_modules/speakingurl/lib/speakingurl.js
var require_speakingurl = __commonJS({
  "node_modules/speakingurl/lib/speakingurl.js"(exports, module) {
    (function(root) {
      "use strict";
      var charMap = {
        // latin
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "Ae",
        "Å": "A",
        "Æ": "AE",
        "Ç": "C",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "Ð": "D",
        "Ñ": "N",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "Oe",
        "Ő": "O",
        "Ø": "O",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "Ue",
        "Ű": "U",
        "Ý": "Y",
        "Þ": "TH",
        "ß": "ss",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "ae",
        "å": "a",
        "æ": "ae",
        "ç": "c",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "ð": "d",
        "ñ": "n",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "oe",
        "ő": "o",
        "ø": "o",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "ue",
        "ű": "u",
        "ý": "y",
        "þ": "th",
        "ÿ": "y",
        "ẞ": "SS",
        // language specific
        // Arabic
        "ا": "a",
        "أ": "a",
        "إ": "i",
        "آ": "aa",
        "ؤ": "u",
        "ئ": "e",
        "ء": "a",
        "ب": "b",
        "ت": "t",
        "ث": "th",
        "ج": "j",
        "ح": "h",
        "خ": "kh",
        "د": "d",
        "ذ": "th",
        "ر": "r",
        "ز": "z",
        "س": "s",
        "ش": "sh",
        "ص": "s",
        "ض": "dh",
        "ط": "t",
        "ظ": "z",
        "ع": "a",
        "غ": "gh",
        "ف": "f",
        "ق": "q",
        "ك": "k",
        "ل": "l",
        "م": "m",
        "ن": "n",
        "ه": "h",
        "و": "w",
        "ي": "y",
        "ى": "a",
        "ة": "h",
        "ﻻ": "la",
        "ﻷ": "laa",
        "ﻹ": "lai",
        "ﻵ": "laa",
        // Persian additional characters than Arabic
        "گ": "g",
        "چ": "ch",
        "پ": "p",
        "ژ": "zh",
        "ک": "k",
        "ی": "y",
        // Arabic diactrics
        "َ": "a",
        "ً": "an",
        "ِ": "e",
        "ٍ": "en",
        "ُ": "u",
        "ٌ": "on",
        "ْ": "",
        // Arabic numbers
        "٠": "0",
        "١": "1",
        "٢": "2",
        "٣": "3",
        "٤": "4",
        "٥": "5",
        "٦": "6",
        "٧": "7",
        "٨": "8",
        "٩": "9",
        // Persian numbers
        "۰": "0",
        "۱": "1",
        "۲": "2",
        "۳": "3",
        "۴": "4",
        "۵": "5",
        "۶": "6",
        "۷": "7",
        "۸": "8",
        "۹": "9",
        // Burmese consonants
        "က": "k",
        "ခ": "kh",
        "ဂ": "g",
        "ဃ": "ga",
        "င": "ng",
        "စ": "s",
        "ဆ": "sa",
        "ဇ": "z",
        "စျ": "za",
        "ည": "ny",
        "ဋ": "t",
        "ဌ": "ta",
        "ဍ": "d",
        "ဎ": "da",
        "ဏ": "na",
        "တ": "t",
        "ထ": "ta",
        "ဒ": "d",
        "ဓ": "da",
        "န": "n",
        "ပ": "p",
        "ဖ": "pa",
        "ဗ": "b",
        "ဘ": "ba",
        "မ": "m",
        "ယ": "y",
        "ရ": "ya",
        "လ": "l",
        "ဝ": "w",
        "သ": "th",
        "ဟ": "h",
        "ဠ": "la",
        "အ": "a",
        // consonant character combos
        "ြ": "y",
        "ျ": "ya",
        "ွ": "w",
        "ြွ": "yw",
        "ျွ": "ywa",
        "ှ": "h",
        // independent vowels
        "ဧ": "e",
        "၏": "-e",
        "ဣ": "i",
        "ဤ": "-i",
        "ဉ": "u",
        "ဦ": "-u",
        "ဩ": "aw",
        "သြော": "aw",
        "ဪ": "aw",
        // numbers
        "၀": "0",
        "၁": "1",
        "၂": "2",
        "၃": "3",
        "၄": "4",
        "၅": "5",
        "၆": "6",
        "၇": "7",
        "၈": "8",
        "၉": "9",
        // virama and tone marks which are silent in transliteration
        "္": "",
        "့": "",
        "း": "",
        // Czech
        "č": "c",
        "ď": "d",
        "ě": "e",
        "ň": "n",
        "ř": "r",
        "š": "s",
        "ť": "t",
        "ů": "u",
        "ž": "z",
        "Č": "C",
        "Ď": "D",
        "Ě": "E",
        "Ň": "N",
        "Ř": "R",
        "Š": "S",
        "Ť": "T",
        "Ů": "U",
        "Ž": "Z",
        // Dhivehi
        "ހ": "h",
        "ށ": "sh",
        "ނ": "n",
        "ރ": "r",
        "ބ": "b",
        "ޅ": "lh",
        "ކ": "k",
        "އ": "a",
        "ވ": "v",
        "މ": "m",
        "ފ": "f",
        "ދ": "dh",
        "ތ": "th",
        "ލ": "l",
        "ގ": "g",
        "ޏ": "gn",
        "ސ": "s",
        "ޑ": "d",
        "ޒ": "z",
        "ޓ": "t",
        "ޔ": "y",
        "ޕ": "p",
        "ޖ": "j",
        "ޗ": "ch",
        "ޘ": "tt",
        "ޙ": "hh",
        "ޚ": "kh",
        "ޛ": "th",
        "ޜ": "z",
        "ޝ": "sh",
        "ޞ": "s",
        "ޟ": "d",
        "ޠ": "t",
        "ޡ": "z",
        "ޢ": "a",
        "ޣ": "gh",
        "ޤ": "q",
        "ޥ": "w",
        "ަ": "a",
        "ާ": "aa",
        "ި": "i",
        "ީ": "ee",
        "ު": "u",
        "ޫ": "oo",
        "ެ": "e",
        "ޭ": "ey",
        "ޮ": "o",
        "ޯ": "oa",
        "ް": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        "ა": "a",
        "ბ": "b",
        "გ": "g",
        "დ": "d",
        "ე": "e",
        "ვ": "v",
        "ზ": "z",
        "თ": "t",
        "ი": "i",
        "კ": "k",
        "ლ": "l",
        "მ": "m",
        "ნ": "n",
        "ო": "o",
        "პ": "p",
        "ჟ": "zh",
        "რ": "r",
        "ს": "s",
        "ტ": "t",
        "უ": "u",
        "ფ": "p",
        "ქ": "k",
        "ღ": "gh",
        "ყ": "q",
        "შ": "sh",
        "ჩ": "ch",
        "ც": "ts",
        "ძ": "dz",
        "წ": "ts",
        "ჭ": "ch",
        "ხ": "kh",
        "ჯ": "j",
        "ჰ": "h",
        // Greek
        "α": "a",
        "β": "v",
        "γ": "g",
        "δ": "d",
        "ε": "e",
        "ζ": "z",
        "η": "i",
        "θ": "th",
        "ι": "i",
        "κ": "k",
        "λ": "l",
        "μ": "m",
        "ν": "n",
        "ξ": "ks",
        "ο": "o",
        "π": "p",
        "ρ": "r",
        "σ": "s",
        "τ": "t",
        "υ": "y",
        "φ": "f",
        "χ": "x",
        "ψ": "ps",
        "ω": "o",
        "ά": "a",
        "έ": "e",
        "ί": "i",
        "ό": "o",
        "ύ": "y",
        "ή": "i",
        "ώ": "o",
        "ς": "s",
        "ϊ": "i",
        "ΰ": "y",
        "ϋ": "y",
        "ΐ": "i",
        "Α": "A",
        "Β": "B",
        "Γ": "G",
        "Δ": "D",
        "Ε": "E",
        "Ζ": "Z",
        "Η": "I",
        "Θ": "TH",
        "Ι": "I",
        "Κ": "K",
        "Λ": "L",
        "Μ": "M",
        "Ν": "N",
        "Ξ": "KS",
        "Ο": "O",
        "Π": "P",
        "Ρ": "R",
        "Σ": "S",
        "Τ": "T",
        "Υ": "Y",
        "Φ": "F",
        "Χ": "X",
        "Ψ": "PS",
        "Ω": "O",
        "Ά": "A",
        "Έ": "E",
        "Ί": "I",
        "Ό": "O",
        "Ύ": "Y",
        "Ή": "I",
        "Ώ": "O",
        "Ϊ": "I",
        "Ϋ": "Y",
        // Latvian
        "ā": "a",
        // 'č': 'c', // duplicate
        "ē": "e",
        "ģ": "g",
        "ī": "i",
        "ķ": "k",
        "ļ": "l",
        "ņ": "n",
        // 'š': 's', // duplicate
        "ū": "u",
        // 'ž': 'z', // duplicate
        "Ā": "A",
        // 'Č': 'C', // duplicate
        "Ē": "E",
        "Ģ": "G",
        "Ī": "I",
        "Ķ": "k",
        "Ļ": "L",
        "Ņ": "N",
        // 'Š': 'S', // duplicate
        "Ū": "U",
        // 'Ž': 'Z', // duplicate
        // Macedonian
        "Ќ": "Kj",
        "ќ": "kj",
        "Љ": "Lj",
        "љ": "lj",
        "Њ": "Nj",
        "њ": "nj",
        "Тс": "Ts",
        "тс": "ts",
        // Polish
        "ą": "a",
        "ć": "c",
        "ę": "e",
        "ł": "l",
        "ń": "n",
        // 'ó': 'o', // duplicate
        "ś": "s",
        "ź": "z",
        "ż": "z",
        "Ą": "A",
        "Ć": "C",
        "Ę": "E",
        "Ł": "L",
        "Ń": "N",
        "Ś": "S",
        "Ź": "Z",
        "Ż": "Z",
        // Ukranian
        "Є": "Ye",
        "І": "I",
        "Ї": "Yi",
        "Ґ": "G",
        "є": "ye",
        "і": "i",
        "ї": "yi",
        "ґ": "g",
        // Romanian
        "ă": "a",
        "Ă": "A",
        "ș": "s",
        "Ș": "S",
        // 'ş': 's', // duplicate
        // 'Ş': 'S', // duplicate
        "ț": "t",
        "Ț": "T",
        "ţ": "t",
        "Ţ": "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        "а": "a",
        "б": "b",
        "в": "v",
        "г": "g",
        "д": "d",
        "е": "e",
        "ё": "yo",
        "ж": "zh",
        "з": "z",
        "и": "i",
        "й": "i",
        "к": "k",
        "л": "l",
        "м": "m",
        "н": "n",
        "о": "o",
        "п": "p",
        "р": "r",
        "с": "s",
        "т": "t",
        "у": "u",
        "ф": "f",
        "х": "kh",
        "ц": "c",
        "ч": "ch",
        "ш": "sh",
        "щ": "sh",
        "ъ": "",
        "ы": "y",
        "ь": "",
        "э": "e",
        "ю": "yu",
        "я": "ya",
        "А": "A",
        "Б": "B",
        "В": "V",
        "Г": "G",
        "Д": "D",
        "Е": "E",
        "Ё": "Yo",
        "Ж": "Zh",
        "З": "Z",
        "И": "I",
        "Й": "I",
        "К": "K",
        "Л": "L",
        "М": "M",
        "Н": "N",
        "О": "O",
        "П": "P",
        "Р": "R",
        "С": "S",
        "Т": "T",
        "У": "U",
        "Ф": "F",
        "Х": "Kh",
        "Ц": "C",
        "Ч": "Ch",
        "Ш": "Sh",
        "Щ": "Sh",
        "Ъ": "",
        "Ы": "Y",
        "Ь": "",
        "Э": "E",
        "Ю": "Yu",
        "Я": "Ya",
        // Serbian
        "ђ": "dj",
        "ј": "j",
        // 'љ': 'lj',  // duplicate
        // 'њ': 'nj', // duplicate
        "ћ": "c",
        "џ": "dz",
        "Ђ": "Dj",
        "Ј": "j",
        // 'Љ': 'Lj', // duplicate
        // 'Њ': 'Nj', // duplicate
        "Ћ": "C",
        "Џ": "Dz",
        // Slovak
        "ľ": "l",
        "ĺ": "l",
        "ŕ": "r",
        "Ľ": "L",
        "Ĺ": "L",
        "Ŕ": "R",
        // Turkish
        "ş": "s",
        "Ş": "S",
        "ı": "i",
        "İ": "I",
        // 'ç': 'c', // duplicate
        // 'Ç': 'C', // duplicate
        // 'ü': 'u', // duplicate, see langCharMap
        // 'Ü': 'U', // duplicate, see langCharMap
        // 'ö': 'o', // duplicate, see langCharMap
        // 'Ö': 'O', // duplicate, see langCharMap
        "ğ": "g",
        "Ğ": "G",
        // Vietnamese
        "ả": "a",
        "Ả": "A",
        "ẳ": "a",
        "Ẳ": "A",
        "ẩ": "a",
        "Ẩ": "A",
        "đ": "d",
        "Đ": "D",
        "ẹ": "e",
        "Ẹ": "E",
        "ẽ": "e",
        "Ẽ": "E",
        "ẻ": "e",
        "Ẻ": "E",
        "ế": "e",
        "Ế": "E",
        "ề": "e",
        "Ề": "E",
        "ệ": "e",
        "Ệ": "E",
        "ễ": "e",
        "Ễ": "E",
        "ể": "e",
        "Ể": "E",
        "ỏ": "o",
        "ọ": "o",
        "Ọ": "o",
        "ố": "o",
        "Ố": "O",
        "ồ": "o",
        "Ồ": "O",
        "ổ": "o",
        "Ổ": "O",
        "ộ": "o",
        "Ộ": "O",
        "ỗ": "o",
        "Ỗ": "O",
        "ơ": "o",
        "Ơ": "O",
        "ớ": "o",
        "Ớ": "O",
        "ờ": "o",
        "Ờ": "O",
        "ợ": "o",
        "Ợ": "O",
        "ỡ": "o",
        "Ỡ": "O",
        "Ở": "o",
        "ở": "o",
        "ị": "i",
        "Ị": "I",
        "ĩ": "i",
        "Ĩ": "I",
        "ỉ": "i",
        "Ỉ": "i",
        "ủ": "u",
        "Ủ": "U",
        "ụ": "u",
        "Ụ": "U",
        "ũ": "u",
        "Ũ": "U",
        "ư": "u",
        "Ư": "U",
        "ứ": "u",
        "Ứ": "U",
        "ừ": "u",
        "Ừ": "U",
        "ự": "u",
        "Ự": "U",
        "ữ": "u",
        "Ữ": "U",
        "ử": "u",
        "Ử": "ư",
        "ỷ": "y",
        "Ỷ": "y",
        "ỳ": "y",
        "Ỳ": "Y",
        "ỵ": "y",
        "Ỵ": "Y",
        "ỹ": "y",
        "Ỹ": "Y",
        "ạ": "a",
        "Ạ": "A",
        "ấ": "a",
        "Ấ": "A",
        "ầ": "a",
        "Ầ": "A",
        "ậ": "a",
        "Ậ": "A",
        "ẫ": "a",
        "Ẫ": "A",
        // 'ă': 'a', // duplicate
        // 'Ă': 'A', // duplicate
        "ắ": "a",
        "Ắ": "A",
        "ằ": "a",
        "Ằ": "A",
        "ặ": "a",
        "Ặ": "A",
        "ẵ": "a",
        "Ẵ": "A",
        "⓪": "0",
        "①": "1",
        "②": "2",
        "③": "3",
        "④": "4",
        "⑤": "5",
        "⑥": "6",
        "⑦": "7",
        "⑧": "8",
        "⑨": "9",
        "⑩": "10",
        "⑪": "11",
        "⑫": "12",
        "⑬": "13",
        "⑭": "14",
        "⑮": "15",
        "⑯": "16",
        "⑰": "17",
        "⑱": "18",
        "⑲": "18",
        "⑳": "18",
        "⓵": "1",
        "⓶": "2",
        "⓷": "3",
        "⓸": "4",
        "⓹": "5",
        "⓺": "6",
        "⓻": "7",
        "⓼": "8",
        "⓽": "9",
        "⓾": "10",
        "⓿": "0",
        "⓫": "11",
        "⓬": "12",
        "⓭": "13",
        "⓮": "14",
        "⓯": "15",
        "⓰": "16",
        "⓱": "17",
        "⓲": "18",
        "⓳": "19",
        "⓴": "20",
        "Ⓐ": "A",
        "Ⓑ": "B",
        "Ⓒ": "C",
        "Ⓓ": "D",
        "Ⓔ": "E",
        "Ⓕ": "F",
        "Ⓖ": "G",
        "Ⓗ": "H",
        "Ⓘ": "I",
        "Ⓙ": "J",
        "Ⓚ": "K",
        "Ⓛ": "L",
        "Ⓜ": "M",
        "Ⓝ": "N",
        "Ⓞ": "O",
        "Ⓟ": "P",
        "Ⓠ": "Q",
        "Ⓡ": "R",
        "Ⓢ": "S",
        "Ⓣ": "T",
        "Ⓤ": "U",
        "Ⓥ": "V",
        "Ⓦ": "W",
        "Ⓧ": "X",
        "Ⓨ": "Y",
        "Ⓩ": "Z",
        "ⓐ": "a",
        "ⓑ": "b",
        "ⓒ": "c",
        "ⓓ": "d",
        "ⓔ": "e",
        "ⓕ": "f",
        "ⓖ": "g",
        "ⓗ": "h",
        "ⓘ": "i",
        "ⓙ": "j",
        "ⓚ": "k",
        "ⓛ": "l",
        "ⓜ": "m",
        "ⓝ": "n",
        "ⓞ": "o",
        "ⓟ": "p",
        "ⓠ": "q",
        "ⓡ": "r",
        "ⓢ": "s",
        "ⓣ": "t",
        "ⓤ": "u",
        "ⓦ": "v",
        "ⓥ": "w",
        "ⓧ": "x",
        "ⓨ": "y",
        "ⓩ": "z",
        // symbols
        "“": '"',
        "”": '"',
        "‘": "'",
        "’": "'",
        "∂": "d",
        "ƒ": "f",
        "™": "(TM)",
        "©": "(C)",
        "œ": "oe",
        "Œ": "OE",
        "®": "(R)",
        "†": "+",
        "℠": "(SM)",
        "…": "...",
        "˚": "o",
        "º": "o",
        "ª": "a",
        "•": "*",
        "၊": ",",
        "။": ".",
        // currency
        "$": "USD",
        "€": "EUR",
        "₢": "BRN",
        "₣": "FRF",
        "£": "GBP",
        "₤": "ITL",
        "₦": "NGN",
        "₧": "ESP",
        "₩": "KRW",
        "₪": "ILS",
        "₫": "VND",
        "₭": "LAK",
        "₮": "MNT",
        "₯": "GRD",
        "₱": "ARS",
        "₲": "PYG",
        "₳": "ARA",
        "₴": "UAH",
        "₵": "GHS",
        "¢": "cent",
        "¥": "CNY",
        "元": "CNY",
        "円": "YEN",
        "﷼": "IRR",
        "₠": "EWE",
        "฿": "THB",
        "₨": "INR",
        "₹": "INR",
        "₰": "PF",
        "₺": "TRY",
        "؋": "AFN",
        "₼": "AZN",
        "лв": "BGN",
        "៛": "KHR",
        "₡": "CRC",
        "₸": "KZT",
        "ден": "MKD",
        "zł": "PLN",
        "₽": "RUB",
        "₾": "GEL"
      };
      var lookAheadCharArray = [
        // burmese
        "်",
        // Dhivehi
        "ް"
      ];
      var diatricMap = {
        // Burmese
        // dependent vowels
        "ာ": "a",
        "ါ": "a",
        "ေ": "e",
        "ဲ": "e",
        "ိ": "i",
        "ီ": "i",
        "ို": "o",
        "ု": "u",
        "ူ": "u",
        "ေါင်": "aung",
        "ော": "aw",
        "ော်": "aw",
        "ေါ": "aw",
        "ေါ်": "aw",
        "်": "်",
        // this is special case but the character will be converted to latin in the code
        "က်": "et",
        "ိုက်": "aik",
        "ောက်": "auk",
        "င်": "in",
        "ိုင်": "aing",
        "ောင်": "aung",
        "စ်": "it",
        "ည်": "i",
        "တ်": "at",
        "ိတ်": "eik",
        "ုတ်": "ok",
        "ွတ်": "ut",
        "ေတ်": "it",
        "ဒ်": "d",
        "ိုဒ်": "ok",
        "ုဒ်": "ait",
        "န်": "an",
        "ာန်": "an",
        "ိန်": "ein",
        "ုန်": "on",
        "ွန်": "un",
        "ပ်": "at",
        "ိပ်": "eik",
        "ုပ်": "ok",
        "ွပ်": "ut",
        "န်ုပ်": "nub",
        "မ်": "an",
        "ိမ်": "ein",
        "ုမ်": "on",
        "ွမ်": "un",
        "ယ်": "e",
        "ိုလ်": "ol",
        "ဉ်": "in",
        "ံ": "an",
        "ိံ": "ein",
        "ုံ": "on",
        // Dhivehi
        "ައް": "ah",
        "ަށް": "ah"
      };
      var langCharMap = {
        "en": {},
        // default language
        "az": {
          // Azerbaijani
          "ç": "c",
          "ə": "e",
          "ğ": "g",
          "ı": "i",
          "ö": "o",
          "ş": "s",
          "ü": "u",
          "Ç": "C",
          "Ə": "E",
          "Ğ": "G",
          "İ": "I",
          "Ö": "O",
          "Ş": "S",
          "Ü": "U"
        },
        "cs": {
          // Czech
          "č": "c",
          "ď": "d",
          "ě": "e",
          "ň": "n",
          "ř": "r",
          "š": "s",
          "ť": "t",
          "ů": "u",
          "ž": "z",
          "Č": "C",
          "Ď": "D",
          "Ě": "E",
          "Ň": "N",
          "Ř": "R",
          "Š": "S",
          "Ť": "T",
          "Ů": "U",
          "Ž": "Z"
        },
        "fi": {
          // Finnish
          // 'å': 'a', duplicate see charMap/latin
          // 'Å': 'A', duplicate see charMap/latin
          "ä": "a",
          // ok
          "Ä": "A",
          // ok
          "ö": "o",
          // ok
          "Ö": "O"
          // ok
        },
        "hu": {
          // Hungarian
          "ä": "a",
          // ok
          "Ä": "A",
          // ok
          // 'á': 'a', duplicate see charMap/latin
          // 'Á': 'A', duplicate see charMap/latin
          "ö": "o",
          // ok
          "Ö": "O",
          // ok
          // 'ő': 'o', duplicate see charMap/latin
          // 'Ő': 'O', duplicate see charMap/latin
          "ü": "u",
          "Ü": "U",
          "ű": "u",
          "Ű": "U"
        },
        "lt": {
          // Lithuanian
          "ą": "a",
          "č": "c",
          "ę": "e",
          "ė": "e",
          "į": "i",
          "š": "s",
          "ų": "u",
          "ū": "u",
          "ž": "z",
          "Ą": "A",
          "Č": "C",
          "Ę": "E",
          "Ė": "E",
          "Į": "I",
          "Š": "S",
          "Ų": "U",
          "Ū": "U"
        },
        "lv": {
          // Latvian
          "ā": "a",
          "č": "c",
          "ē": "e",
          "ģ": "g",
          "ī": "i",
          "ķ": "k",
          "ļ": "l",
          "ņ": "n",
          "š": "s",
          "ū": "u",
          "ž": "z",
          "Ā": "A",
          "Č": "C",
          "Ē": "E",
          "Ģ": "G",
          "Ī": "i",
          "Ķ": "k",
          "Ļ": "L",
          "Ņ": "N",
          "Š": "S",
          "Ū": "u",
          "Ž": "Z"
        },
        "pl": {
          // Polish
          "ą": "a",
          "ć": "c",
          "ę": "e",
          "ł": "l",
          "ń": "n",
          "ó": "o",
          "ś": "s",
          "ź": "z",
          "ż": "z",
          "Ą": "A",
          "Ć": "C",
          "Ę": "e",
          "Ł": "L",
          "Ń": "N",
          "Ó": "O",
          "Ś": "S",
          "Ź": "Z",
          "Ż": "Z"
        },
        "sv": {
          // Swedish
          // 'å': 'a', duplicate see charMap/latin
          // 'Å': 'A', duplicate see charMap/latin
          "ä": "a",
          // ok
          "Ä": "A",
          // ok
          "ö": "o",
          // ok
          "Ö": "O"
          // ok
        },
        "sk": {
          // Slovak
          "ä": "a",
          "Ä": "A"
        },
        "sr": {
          // Serbian
          "љ": "lj",
          "њ": "nj",
          "Љ": "Lj",
          "Њ": "Nj",
          "đ": "dj",
          "Đ": "Dj"
        },
        "tr": {
          // Turkish
          "Ü": "U",
          "Ö": "O",
          "ü": "u",
          "ö": "o"
        }
      };
      var symbolMap = {
        "ar": {
          "∆": "delta",
          "∞": "la-nihaya",
          "♥": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "∑": "majmou",
          "¤": "omla"
        },
        "az": {},
        "ca": {
          "∆": "delta",
          "∞": "infinit",
          "♥": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "∑": "suma dels",
          "¤": "moneda"
        },
        "cs": {
          "∆": "delta",
          "∞": "nekonecno",
          "♥": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "∑": "soucet",
          "¤": "mena"
        },
        "de": {
          "∆": "delta",
          "∞": "unendlich",
          "♥": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "∑": "Summe von",
          "¤": "Waehrung"
        },
        "dv": {
          "∆": "delta",
          "∞": "kolunulaa",
          "♥": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "∑": "jumula",
          "¤": "faisaa"
        },
        "en": {
          "∆": "delta",
          "∞": "infinity",
          "♥": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "∑": "sum",
          "¤": "currency"
        },
        "es": {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "∑": "suma de los",
          "¤": "moneda"
        },
        "fa": {
          "∆": "delta",
          "∞": "bi-nahayat",
          "♥": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "∑": "majmooe",
          "¤": "vahed"
        },
        "fi": {
          "∆": "delta",
          "∞": "aarettomyys",
          "♥": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "∑": "summa",
          "¤": "valuutta"
        },
        "fr": {
          "∆": "delta",
          "∞": "infiniment",
          "♥": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "∑": "somme des",
          "¤": "monnaie"
        },
        "ge": {
          "∆": "delta",
          "∞": "usasruloba",
          "♥": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "∑": "jami",
          "¤": "valuta"
        },
        "gr": {},
        "hu": {
          "∆": "delta",
          "∞": "vegtelen",
          "♥": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "∑": "szumma",
          "¤": "penznem"
        },
        "it": {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "∑": "somma",
          "¤": "moneta"
        },
        "lt": {
          "∆": "delta",
          "∞": "begalybe",
          "♥": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "∑": "suma",
          "¤": "valiuta"
        },
        "lv": {
          "∆": "delta",
          "∞": "bezgaliba",
          "♥": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "∑": "summa",
          "¤": "valuta"
        },
        "my": {
          "∆": "kwahkhyaet",
          "∞": "asaonasme",
          "♥": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "∑": "paungld",
          "¤": "ngwekye"
        },
        "mk": {},
        "nl": {
          "∆": "delta",
          "∞": "oneindig",
          "♥": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "∑": "som",
          "¤": "valuta"
        },
        "pl": {
          "∆": "delta",
          "∞": "nieskonczonosc",
          "♥": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "∑": "suma",
          "¤": "waluta"
        },
        "pt": {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "∑": "soma",
          "¤": "moeda"
        },
        "ro": {
          "∆": "delta",
          "∞": "infinit",
          "♥": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "∑": "suma",
          "¤": "valuta"
        },
        "ru": {
          "∆": "delta",
          "∞": "beskonechno",
          "♥": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "∑": "summa",
          "¤": "valjuta"
        },
        "sk": {
          "∆": "delta",
          "∞": "nekonecno",
          "♥": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "∑": "sucet",
          "¤": "mena"
        },
        "sr": {},
        "tr": {
          "∆": "delta",
          "∞": "sonsuzluk",
          "♥": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "∑": "toplam",
          "¤": "para birimi"
        },
        "uk": {
          "∆": "delta",
          "∞": "bezkinechnist",
          "♥": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "∑": "suma",
          "¤": "valjuta"
        },
        "vn": {
          "∆": "delta",
          "∞": "vo cuc",
          "♥": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "∑": "tong",
          "¤": "tien te"
        }
      };
      var uricChars = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join("");
      var uricNoSlashChars = [";", "?", ":", "@", "&", "=", "+", "$", ","].join("");
      var markChars = [".", "!", "~", "*", "'", "(", ")"].join("");
      var getSlug = function getSlug2(input, opts) {
        var separator = "-";
        var result = "";
        var diatricString = "";
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = "";
        if (typeof input !== "string") {
          return "";
        }
        if (typeof opts === "string") {
          separator = opts;
        }
        symbol = symbolMap.en;
        langChar = langCharMap.en;
        if (typeof opts === "object") {
          maintainCase = opts.maintainCase || false;
          customReplacements = opts.custom && typeof opts.custom === "object" ? opts.custom : customReplacements;
          truncate = +opts.truncate > 1 && opts.truncate || false;
          uricFlag = opts.uric || false;
          uricNoSlashFlag = opts.uricNoSlash || false;
          markFlag = opts.mark || false;
          convertSymbols = opts.symbols === false || opts.lang === false ? false : true;
          separator = opts.separator || separator;
          if (uricFlag) {
            allowedChars += uricChars;
          }
          if (uricNoSlashFlag) {
            allowedChars += uricNoSlashChars;
          }
          if (markFlag) {
            allowedChars += markChars;
          }
          symbol = opts.lang && symbolMap[opts.lang] && convertSymbols ? symbolMap[opts.lang] : convertSymbols ? symbolMap.en : {};
          langChar = opts.lang && langCharMap[opts.lang] ? langCharMap[opts.lang] : opts.lang === false || opts.lang === true ? {} : langCharMap.en;
          if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {
            opts.titleCase.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
            titleCase = true;
          } else {
            titleCase = !!opts.titleCase;
          }
          if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {
            opts.custom.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
          }
          Object.keys(customReplacements).forEach(function(v) {
            var r;
            if (v.length > 1) {
              r = new RegExp("\\b" + escapeChars(v) + "\\b", "gi");
            } else {
              r = new RegExp(escapeChars(v), "gi");
            }
            input = input.replace(r, customReplacements[v]);
          });
          for (ch in customReplacements) {
            allowedChars += ch;
          }
        }
        allowedChars += separator;
        allowedChars = escapeChars(allowedChars);
        input = input.replace(/(^\s+|\s+$)/g, "");
        lastCharWasSymbol = false;
        lastCharWasDiatric = false;
        for (i = 0, l = input.length; i < l; i++) {
          ch = input[i];
          if (isReplacedCustomChar(ch, customReplacements)) {
            lastCharWasSymbol = false;
          } else if (langChar[ch]) {
            ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? " " + langChar[ch] : langChar[ch];
            lastCharWasSymbol = false;
          } else if (ch in charMap) {
            if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
              diatricString += ch;
              ch = "";
            } else if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + charMap[ch];
              diatricString = "";
            } else {
              ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? " " + charMap[ch] : charMap[ch];
            }
            lastCharWasSymbol = false;
            lastCharWasDiatric = false;
          } else if (ch in diatricMap) {
            diatricString += ch;
            ch = "";
            if (i === l - 1) {
              ch = diatricMap[diatricString];
            }
            lastCharWasDiatric = true;
          } else if (
            // process symbol chars
            symbol[ch] && !(uricFlag && uricChars.indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.indexOf(ch) !== -1)
          ) {
            ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
            ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : "";
            lastCharWasSymbol = true;
          } else {
            if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + ch;
              diatricString = "";
              lastCharWasDiatric = false;
            } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
              ch = " " + ch;
            }
            lastCharWasSymbol = false;
          }
          result += ch.replace(new RegExp("[^\\w\\s" + allowedChars + "_-]", "g"), separator);
        }
        if (titleCase) {
          result = result.replace(/(\w)(\S*)/g, function(_, i2, r) {
            var j = i2.toUpperCase() + (r !== null ? r : "");
            return Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0 ? j : j.toLowerCase();
          });
        }
        result = result.replace(/\s+/g, separator).replace(new RegExp("\\" + separator + "+", "g"), separator).replace(new RegExp("(^\\" + separator + "+|\\" + separator + "+$)", "g"), "");
        if (truncate && result.length > truncate) {
          lucky = result.charAt(truncate) === separator;
          result = result.slice(0, truncate);
          if (!lucky) {
            result = result.slice(0, result.lastIndexOf(separator));
          }
        }
        if (!maintainCase && !titleCase) {
          result = result.toLowerCase();
        }
        return result;
      };
      var createSlug = function createSlug2(opts) {
        return function getSlugWithConfig(input) {
          return getSlug(input, opts);
        };
      };
      var escapeChars = function escapeChars2(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      };
      var isReplacedCustomChar = function(ch, customReplacements) {
        for (var c in customReplacements) {
          if (customReplacements[c] === ch) {
            return true;
          }
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return getSlug;
        });
      } else {
        try {
          if (root.getSlug || root.createSlug) {
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          } else {
            root.getSlug = getSlug;
            root.createSlug = createSlug;
          }
        } catch (e) {
        }
      }
    })(exports);
  }
});

// node_modules/speakingurl/index.js
var require_speakingurl2 = __commonJS({
  "node_modules/speakingurl/index.js"(exports, module) {
    module.exports = require_speakingurl();
  }
});

// node_modules/shortid/lib/random/random-from-seed.js
var require_random_from_seed = __commonJS({
  "node_modules/shortid/lib/random/random-from-seed.js"(exports, module) {
    "use strict";
    var seed = 1;
    function getNextValue() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }
    function setSeed(_seed_) {
      seed = _seed_;
    }
    module.exports = {
      nextValue: getNextValue,
      seed: setSeed
    };
  }
});

// node_modules/shortid/lib/alphabet.js
var require_alphabet = __commonJS({
  "node_modules/shortid/lib/alphabet.js"(exports, module) {
    "use strict";
    var randomFromSeed = require_random_from_seed();
    var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    var alphabet;
    var previousSeed;
    var shuffled;
    function reset() {
      shuffled = false;
    }
    function setCharacters(_alphabet_) {
      if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
          alphabet = ORIGINAL;
          reset();
        }
        return;
      }
      if (_alphabet_ === alphabet) {
        return;
      }
      if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
      }
      var unique = _alphabet_.split("").filter(function(item, ind, arr) {
        return ind !== arr.lastIndexOf(item);
      });
      if (unique.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
      }
      alphabet = _alphabet_;
      reset();
    }
    function characters(_alphabet_) {
      setCharacters(_alphabet_);
      return alphabet;
    }
    function setSeed(seed) {
      randomFromSeed.seed(seed);
      if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
      }
    }
    function shuffle() {
      if (!alphabet) {
        setCharacters(ORIGINAL);
      }
      var sourceArray = alphabet.split("");
      var targetArray = [];
      var r = randomFromSeed.nextValue();
      var characterIndex;
      while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
      }
      return targetArray.join("");
    }
    function getShuffled() {
      if (shuffled) {
        return shuffled;
      }
      shuffled = shuffle();
      return shuffled;
    }
    function lookup(index) {
      var alphabetShuffled = getShuffled();
      return alphabetShuffled[index];
    }
    function get() {
      return alphabet || ORIGINAL;
    }
    module.exports = {
      get,
      characters,
      seed: setSeed,
      lookup,
      shuffled: getShuffled
    };
  }
});

// node_modules/shortid/lib/random/random-byte-browser.js
var require_random_byte_browser = __commonJS({
  "node_modules/shortid/lib/random/random-byte-browser.js"(exports, module) {
    "use strict";
    var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
    var randomByte;
    if (!crypto || !crypto.getRandomValues) {
      randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
          bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
      };
    } else {
      randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
      };
    }
    module.exports = randomByte;
  }
});

// node_modules/shortid/node_modules/nanoid/format.browser.js
var require_format_browser = __commonJS({
  "node_modules/shortid/node_modules/nanoid/format.browser.js"(exports, module) {
    module.exports = function(random, alphabet, size) {
      var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      var step = -~(1.6 * mask * size / alphabet.length);
      var id = "";
      while (true) {
        var bytes = random(step);
        var i = step;
        while (i--) {
          id += alphabet[bytes[i] & mask] || "";
          if (id.length === +size)
            return id;
        }
      }
    };
  }
});

// node_modules/shortid/lib/generate.js
var require_generate = __commonJS({
  "node_modules/shortid/lib/generate.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var random = require_random_byte_browser();
    var format = require_format_browser();
    function generate(number) {
      var loopCounter = 0;
      var done;
      var str = "";
      while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < Math.pow(16, loopCounter + 1);
        loopCounter++;
      }
      return str;
    }
    module.exports = generate;
  }
});

// node_modules/shortid/lib/build.js
var require_build = __commonJS({
  "node_modules/shortid/lib/build.js"(exports, module) {
    "use strict";
    var generate = require_generate();
    var alphabet = require_alphabet();
    var REDUCE_TIME = 1567752802062;
    var version = 7;
    var counter;
    var previousSeconds;
    function build(clusterWorkerId) {
      var str = "";
      var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
      if (seconds === previousSeconds) {
        counter++;
      } else {
        counter = 0;
        previousSeconds = seconds;
      }
      str = str + generate(version);
      str = str + generate(clusterWorkerId);
      if (counter > 0) {
        str = str + generate(counter);
      }
      str = str + generate(seconds);
      return str;
    }
    module.exports = build;
  }
});

// node_modules/shortid/lib/is-valid.js
var require_is_valid = __commonJS({
  "node_modules/shortid/lib/is-valid.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    function isShortId(id) {
      if (!id || typeof id !== "string" || id.length < 6) {
        return false;
      }
      var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
      return !nonAlphabetic.test(id);
    }
    module.exports = isShortId;
  }
});

// node_modules/shortid/lib/util/cluster-worker-id-browser.js
var require_cluster_worker_id_browser = __commonJS({
  "node_modules/shortid/lib/util/cluster-worker-id-browser.js"(exports, module) {
    "use strict";
    module.exports = 0;
  }
});

// node_modules/shortid/lib/index.js
var require_lib = __commonJS({
  "node_modules/shortid/lib/index.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var build = require_build();
    var isValid = require_is_valid();
    var clusterWorkerId = require_cluster_worker_id_browser() || 0;
    function seed(seedValue) {
      alphabet.seed(seedValue);
      return module.exports;
    }
    function worker(workerId) {
      clusterWorkerId = workerId;
      return module.exports;
    }
    function characters(newCharacters) {
      if (newCharacters !== void 0) {
        alphabet.characters(newCharacters);
      }
      return alphabet.shuffled();
    }
    function generate() {
      return build(clusterWorkerId);
    }
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.isValid = isValid;
  }
});

// node_modules/shortid/index.js
var require_shortid = __commonJS({
  "node_modules/shortid/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/mongoose-slug-updater/lib/slug-generator.js
var require_slug_generator = __commonJS({
  "node_modules/mongoose-slug-updater/lib/slug-generator.js"(exports, module) {
    var _ = require_deepdash()(require_lodash());
    var getSlug = require_speakingurl2();
    var shortId = require_shortid();
    module.exports = function plugin(schema, options) {
      options = _.merge(
        {
          separator: "-",
          lang: "en",
          truncate: 120,
          backwardCompatible: true
        },
        options
      );
      const slugs = [];
      function schemaTraversal(schema2, basePath, cb) {
        if (basePath)
          basePath += ".";
        schema2.eachPath((schemaPath, schemaType) => {
          if (schemaType.caster && schemaType.caster.schema) {
            schemaTraversal(
              schemaType.caster.schema,
              basePath + schemaPath + (schemaType.constructor.schemaName == "DocumentArray" ? ".$" : ""),
              cb
            );
          } else {
            cb(basePath + schemaPath, schemaType);
          }
        });
      }
      function renameOldOptions(opts) {
        if (!options.backwardCompatible)
          return opts;
        const res = _.cloneDeep(opts);
        const deprecated = ["unique_slug", "slug_padding_size"];
        const found = [];
        _.each(deprecated, (oldo) => {
          if (res[oldo] !== void 0) {
            const newo = _.camelCase(oldo);
            found.push([oldo, newo]);
            res[newo] = res[oldo];
            delete res[oldo];
          }
        });
        if (found.length) {
          console.log(
            'Deprecated "snake_case" options found by slug updater plugin. Please update to camelCase.',
            found
          );
        }
        if (res.uniqueGroup) {
          res.uniqueGroupSlug = res.uniqueGroup;
          delete res.uniqueGroup;
          console.log(
            'Deprecated option "uniqueGroup" found by slug updater. Please update to uniqueGroupSlug.'
          );
        }
        if (res.force_id) {
          res.forceIdSlug = res.force_id;
          delete res.force_id;
          console.log(
            'Deprecated option "force_id" found by slug updater. Please update to forceIdSlug.'
          );
        }
        if (res.on) {
          res.slugOn = res.on;
          delete res.on;
          console.log('Deprecated option "on" found by slug updater. Please update to slugOn.');
        }
        return res;
      }
      schemaTraversal(schema, "", (schemaPath, schemaType) => {
        if (schemaType.instance == "String" && schemaType.options && schemaType.options.slug) {
          const opts = renameOldOptions(schemaType.options);
          let basePath = schemaPath.replace(/[.][^.]+$/, "");
          if (basePath === schemaPath)
            basePath = "";
          const slug = {
            path: schemaPath,
            basePath,
            on: {
              save: true,
              update: true,
              updateOne: true,
              updateMany: true,
              findOneAndUpdate: true,
              ...opts.slugOn || {}
            }
          };
          if (typeof opts.slug === "string") {
            slug.fields = [opts.slug];
          } else if (opts.slug instanceof Array) {
            slug.fields = opts.slug;
          } else {
            console.warn(
              `slug option expected to be string or array. ${typeof opts.slug} found and will be ignored.`
            );
            return;
          }
          if (opts.unique || opts.uniqueSlug) {
            slug.unique = true;
          }
          if (opts.permanent) {
            slug.permanent = true;
          }
          if (opts.slugPaddingSize === void 0) {
            slug.isShortIdMode = true;
          } else {
            slug.isShortIdMode = false;
            slug.padding = opts.slugPaddingSize;
          }
          if (opts.uniqueGroupSlug) {
            if (_.isArray(opts.uniqueGroupSlug)) {
              slug.uniqueGroupFields = opts.uniqueGroupSlug;
            } else {
              slug.uniqueGroupFields = [opts.uniqueGroupSlug];
            }
          }
          if (opts.forceIdSlug) {
            slug.unique = true;
            slug.isShortIdMode = true;
            slug.forceShortId = true;
          }
          if (opts.transform) {
            slug.transform = opts.transform;
          }
          slugs.push(slug);
        }
      });
      schema.pre("update", async function() {
        return onUpdate.bind(this)("update");
      });
      schema.pre("updateOne", async function() {
        return onUpdate.bind(this)("updateOne");
      });
      schema.pre("updateMany", async function() {
        return onUpdate.bind(this)("updateMany");
      });
      schema.pre("findOneAndUpdate", async function() {
        return onUpdate.bind(this)("findOneAndUpdate");
      });
      async function onUpdate(operation) {
        const me = this;
        const upd = me.getUpdate();
        const doc = _.cloneDeep(upd);
        if (doc.$set) {
          _.forOwn(doc.$set, (v, k) => {
            _.set(doc, k, v);
          });
          delete doc.$set;
        }
        const docs = [_.cloneDeep(doc)];
        const unwoundSlugs = unwindSlugs(doc, _.filter(slugs, `on.${operation}`));
        if (!unwoundSlugs.length) {
          return;
        }
        const updFields = _.keysDeep(doc);
        const involvedPaths = _.uniq(
          unwoundSlugs.reduce((acc, slug) => acc.concat(slug.fields).concat([slug.path]), [])
        ).map((p) => p.replace(/^\//, ""));
        let involvedValuesDocs = await me.model[operation == "updateOne" ? "findOne" : "find"](
          me.getQuery(),
          _(involvedPaths).map((k) => [k.replace(/\.[$\d]+\./g, "."), 1]).fromPairs().value()
        );
        if (involvedValuesDocs) {
          if (!_.isArray(involvedValuesDocs))
            involvedValuesDocs = [involvedValuesDocs];
          involvedValuesDocs.forEach((freshDoc, i) => {
            if (i)
              docs[i] = _.cloneDeep(doc);
            involvedPaths.forEach((f) => {
              const fs = unwindPath(freshDoc, f);
              _.each(fs, (f2) => {
                if (_.get(docs[i], f2) === void 0)
                  _.set(docs[i], f2, _.get(freshDoc, f2));
              });
            });
            if (freshDoc && freshDoc._id)
              docs[i]._id = freshDoc._id;
          });
        }
        const slugsUpd = [];
        const cache = {};
        async function findOne(query, sort) {
          let res = me.model.findOne(query);
          if (sort) {
            res = res.sort(sort);
          }
          return res;
        }
        for (let i = 0; i < docs.length; i++) {
          const currentUnwoundFields = unwindSlugs(docs[i], unwoundSlugs);
          let actualSlugs = currentUnwoundFields;
          if (involvedValuesDocs && involvedValuesDocs.length) {
            const actualUpdFields = _(updFields).filter((f) => _.get(doc, f) != _.get(involvedValuesDocs[i], f)).map((f) => _.trim(f.replace(/\["?(.+?)"?\]/g, ".$1"), ".")).value();
            actualSlugs = _.filter(
              currentUnwoundFields,
              (s) => _.intersection(
                _.map(s.fields.concat(s.uniqueGroupFields || []), (p) => p.replace(/^\//, "")),
                actualUpdFields
              ).length
            );
          }
          if (actualSlugs.length) {
            await setSlugs(docs[i], actualSlugs, options, findOne, cache);
          }
          slugsUpd[i] = {};
          const origUpd = _.reduce(
            upd.$set,
            (r, v, k) => {
              _.set(r, k, v);
              return r;
            },
            {}
          ) || upd;
          actualSlugs.forEach((slug) => {
            const slugVal = _.get(docs[i], slug.path);
            if (slugVal !== void 0)
              _.set(slugsUpd[i], slug.path, slugVal);
          });
          if (involvedValuesDocs && involvedValuesDocs.length) {
            _.each(currentUnwoundFields, (us) => {
              if (!_.has(origUpd, us.path) && !_.has(slugsUpd[i], us.path)) {
                const val = _.get(involvedValuesDocs[i], us.path);
                if (val !== void 0)
                  _.set(slugsUpd[i], us.path, val);
              }
            });
          }
          let doUpd = slugsUpd[i];
          if (upd.$set) {
            const slugPaths = _(doUpd).index({ leafsOnly: true }).mapKeys((v, f) => _.trim(f.replace(/\["?(.+?)"?\]/g, ".$1"), ".")).omitBy((v) => v === void 0).value();
            doUpd = { $set: slugPaths };
          }
          if (docs.length == 1) {
            if (doUpd)
              me[operation]({}, _.merge(me.getUpdate(), doUpd));
          } else {
            if (doUpd) {
              await me.model.updateOne({ _id: docs[i]._id }, doUpd);
            }
          }
        }
      }
      schema.pre("save", async function() {
        const cache = {};
        let doc = this;
        if (!doc.model) {
          return;
        }
        const reSlug = false;
        const unwoundSlugs = unwindSlugs(doc, _.filter(slugs, "on.save"));
        if (!unwoundSlugs.length) {
          return;
        }
        doc = await setSlugs(
          doc,
          unwoundSlugs,
          options,
          async (query, sort) => {
            let res = doc.model(doc.constructor.modelName).findOne(query);
            if (sort)
              res = res.sort(sort);
            return res;
          },
          cache
        );
      });
    };
    function updateUpdCache(cache, path, slug, value, group) {
      const maskedPath = path.replace(/\.[$\d]+\./g, ".$.");
      const isArrayPath = path != maskedPath;
      const localKey = `${maskedPath}:${slug}`;
      if (isArrayPath) {
        cache.lock[path].ext.resolveEx(value);
        delete cache.lock[path];
      } else {
        const key = `${localKey}-${JSON.stringify(group)}`;
        cache.db[key] = value;
      }
    }
    async function findSame(cache, doc, group, path, slug, isCounter, options, findOne, permanent) {
      cache = _.merge(cache, { db: {}, unwind: {}, upd: {}, lock: {} });
      const maskedPath = path.replace(/\.[$\d]+\./g, ".$.");
      const isArrayPath = path != maskedPath;
      const slugRx = new RegExp(`^${slug}(${options.separator}${isCounter ? "(\\d+)" : "(.+)"})?$`);
      const localKey = `${maskedPath}:${slug}`;
      const key = `${localKey}-${JSON.stringify(group)}`;
      if (isArrayPath) {
        const ext = { path };
        const updPromise = new Promise((resolve, reject) => {
          ext.resolveEx = resolve;
          ext.rejectEx = reject;
        });
        updPromise.ext = ext;
        if (cache.upd[localKey] !== void 0) {
          let res = cache.upd[localKey];
          cache.upd[localKey] = updPromise;
          const fromPath = res.ext.path;
          cache.lock[path] = updPromise;
          res = await res;
          return res;
        }
        cache.upd[localKey] = updPromise;
        cache.lock[path] = updPromise;
      }
      let query = _.cloneDeep(group);
      const sort = {};
      if (cache.db[key] === void 0) {
        const arrayPath = path.replace(/\.[$\d]+\./g, ".");
        query[arrayPath] = slugRx;
        if (doc._id) {
          if (query._id == void 0) {
            query._id = {
              $ne: doc._id
            };
          } else if (!permanent) {
            query = false;
          }
        }
        if (query !== false) {
          if (isCounter)
            sort[arrayPath] = -1;
          cache.db[key] = findOne(query, sort);
        } else {
          cache.db[key] = null;
        }
      }
      if (_.isObject(cache.db[key]) && _.isFunction(cache.db[key].then)) {
        let foundDoc = await cache.db[key];
        if (_.isObject(cache.db[key]) && _.isFunction(cache.db[key].then)) {
          if (!foundDoc) {
            cache.db[key] = null;
          } else {
            foundDoc = _(unwindPath(foundDoc, maskedPath)).map((p) => [p, docGet(foundDoc, p)]).filter(([p, v]) => v.match(slugRx)).sortBy("[1]").last();
            cache.db[key] = foundDoc[1];
          }
        }
      }
      return cache.db[key];
    }
    var docGet = (doc, path) => {
      return _.isFunction(doc.get) ? doc.get(path) : _.get(doc, path);
    };
    var docSet = (doc, path, val) => _.isFunction(doc.set) ? doc.set(path, val) : _.set(doc, path, val);
    var docIsModified = (doc, path) => _.isFunction(doc.isModified) ? doc.isModified(path) : _.get(doc, path) !== void 0;
    function unwindSlugs(doc, slugs) {
      const unwoundSlugs = [];
      slugs.forEach((slug) => {
        const slugPaths = unwindPath(doc, slug.path);
        if (!slugPaths.length)
          slugPaths.push(slug.path);
        let { basePath } = slug;
        if (_.endsWith(basePath, ".$"))
          basePath += ".";
        slugPaths.forEach((slugPath) => {
          let unwoundBasePath = slugPath.replace(/\.[^\.]+$/, "");
          if (unwoundBasePath == slugPath)
            unwoundBasePath = "";
          function unwindFieldPath(fieldPath) {
            let slugValueBasePath = unwoundBasePath;
            let originalBasePath = _.trimEnd(basePath, ".");
            while (_.startsWith(fieldPath, ":")) {
              let prevValueBasePath = slugValueBasePath;
              let prevOriginalBasePath = originalBasePath;
              if (slugValueBasePath.match(/\.[$\d]+$/)) {
                slugValueBasePath = slugValueBasePath.replace(/\.[$\d]+$/, "");
                prevValueBasePath = slugValueBasePath;
              }
              if (originalBasePath.match(/\.[$\d]+$/)) {
                originalBasePath = originalBasePath.replace(/\.[$\d]+$/, "");
                prevOriginalBasePath = originalBasePath;
              }
              slugValueBasePath = slugValueBasePath.replace(/\.[^\.]+$/, "");
              originalBasePath = originalBasePath.replace(/\.[^\.]+$/, "");
              if (slugValueBasePath == prevValueBasePath)
                slugValueBasePath = "";
              if (originalBasePath == prevOriginalBasePath)
                originalBasePath = "";
              fieldPath = fieldPath.substr(1);
            }
            if (!_.startsWith(fieldPath, "/")) {
              fieldPath = `/${slugValueBasePath && `${slugValueBasePath}.` || ""}${fieldPath}`;
            }
            if (_.startsWith(fieldPath, `/${originalBasePath}`))
              fieldPath = fieldPath.replace(`/${originalBasePath}`, `/${slugValueBasePath}`);
            return fieldPath;
          }
          const unwoundFields = slug.fields.map(unwindFieldPath);
          const unwoundGroupPaths = (slug.uniqueGroupFields || []).map(unwindFieldPath);
          if (_.some(
            unwoundFields.concat(unwoundGroupPaths),
            (path) => docIsModified(doc, path.replace(/^\//, ""))
          )) {
            const s = _.cloneDeep(slug);
            s.path = slugPath;
            s.basePath = unwoundBasePath;
            s.fields = unwoundFields;
            s.uniqueGroupFields = unwoundGroupPaths;
            unwoundSlugs.push(s);
          }
        });
      });
      return unwoundSlugs;
    }
    function unwindPath(doc, path, restPathParts) {
      if (restPathParts === void 0) {
        restPathParts = path.split(".$.");
        path = restPathParts[0];
        restPathParts = _.drop(restPathParts);
      }
      let res = [];
      const value = docGet(doc, path);
      if (_.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const childPath = `${path}.${i}.${restPathParts[0]}`;
          res = res.concat(unwindPath(doc, childPath, _.drop(restPathParts)));
        }
      } else if (!restPathParts || !restPathParts.length)
        res.push(path);
      return res;
    }
    async function setSlugs(doc, slugs, options, findOne, cache) {
      await Promise.all(
        slugs.map(async (slug) => {
          const fields = [];
          slug.fields.forEach((slugField) => {
            let fieldVal = docGet(doc, slugField.replace(/^\//, ""));
            if (slug.transform) {
              fieldVal = slug.transform(fieldVal);
            }
            fields.push(fieldVal);
          });
          const oldSlug = docGet(doc, slug.path);
          if (!(slug.unique || slug.uniqueSlug) && (!slug.uniqueGroupFields || !slug.uniqueGroupFields.length)) {
            if (!oldSlug || !slug.permanent) {
              docSet(doc, slug.path, makeSlug(fields, options));
            }
          } else {
            const query = {};
            if (slug.uniqueGroupFields) {
              slug.uniqueGroupFields.forEach((fieldName) => {
                fieldName = fieldName.replace(/^\//, "");
                query[fieldName] = docGet(doc, fieldName);
              });
            }
            if (!docGet(doc, slug.path) || !slug.permanent) {
              if (slug.isShortIdMode) {
                docSet(
                  doc,
                  slug.path,
                  await makeUniqueShortIdSlug(
                    doc,
                    slug.path,
                    fields,
                    options,
                    query,
                    findOne,
                    slug.forceShortId,
                    cache
                    // slugsMdfPaths
                  )
                );
              } else {
                docSet(
                  doc,
                  slug.path,
                  await makeUniqueCounterSlug(
                    doc,
                    slug.path,
                    fields,
                    options,
                    slug.padding,
                    query,
                    findOne,
                    cache,
                    slug.permanent
                    // slugsMdfPaths
                  )
                );
              }
            }
          }
        })
      );
      return doc;
    }
    function makeSlug(values, options) {
      const slug = getSlug(values.join(" "), options);
      return slug;
    }
    function extractCounter(value, separator) {
      let count = 0;
      const test = new RegExp(`${separator}(\\d+)$`);
      let match = null;
      if (match = value.match(test)) {
        count = match[1];
      }
      return parseInt(count);
    }
    async function makeUniqueCounterSlug(doc, path, values, options, padding, groups, findOne, cache, permanent) {
      let slug = makeSlug(values, options);
      const originalSlug = slug;
      let count = 0;
      const result = await findSame(
        cache,
        doc,
        groups,
        path,
        slug,
        true,
        options,
        findOne,
        permanent
        // slugsMdfPaths
      );
      if (result) {
        count = extractCounter(result, options.separator) + 1;
        slug += options.separator + _.padStart(count, padding, "0");
      }
      updateUpdCache(cache, path, originalSlug, slug, groups);
      return slug;
    }
    async function makeUniqueShortIdSlug(doc, path, values, options, groups, findOne, forceShortId, cache) {
      let slug = makeSlug(values, options);
      const originalSlug = slug;
      const result = await findSame(
        cache,
        doc,
        groups,
        path,
        slug,
        false,
        options,
        findOne
        // slugsMdfPaths
      );
      if (result) {
        const oldSlug = docGet(doc, path);
        if (
          // reuse old slug if possible
          oldSlug && oldSlug.match(new RegExp(`^${slug}${options.separator}.*$`))
        ) {
          slug = oldSlug;
        } else
          slug += options.separator + shortId.generate();
      } else if (forceShortId) {
        slug += options.separator + shortId.generate();
      }
      updateUpdCache(cache, path, originalSlug, slug, groups);
      return slug;
    }
  }
});

// node_modules/mongoose-slug-updater/index.js
var require_mongoose_slug_updater = __commonJS({
  "node_modules/mongoose-slug-updater/index.js"(exports, module) {
    module.exports = require_slug_generator();
  }
});
export default require_mongoose_slug_updater();
//# sourceMappingURL=mongoose-slug-updater.js.map
